\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or eps with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}        % so we can use the 'pretty' empty set
\usepackage{tipa}
\usepackage{graphicx}           % purdy pitchers
\usepackage{algorithmic}
\usepackage{phonrule}

\usepackage{cite}
\usepackage{apacite}

\newtheorem{definition}{Definition}

\title{An algorithm to assign features to a set of phonological classes}
\author{}
\author{
  Mayer, Connor \\
  \texttt{connormayer@ucla.edu}
  \and
  Daland, Robert \\
  \texttt{r.daland@gmail.com}
}
\date{\vspace{-5ex}}							% Activate to display a given date or no date

\begin{document}
\maketitle

\begin{abstract}
This paper describes a collection of dynamic programming algorithms which assign features to a set of phonological classes. The input consists of a set of classes, each containing one or more segments. If a class can be generated as the union of existing features (i.e. as the intersection of already-processed classes), those features are propagated to every segment in the class. A new feature/value pair must be assigned otherwise, and we show that this occurs just in case the class has a single parent in the intersectional closure of the input. The algorithm comes in four flavors, which differ with respect to complementation and how negative values are assigned. We show that these variants yield \textit{privative specification}, \textit{contrastive underspecification}, \textit{contrastive specification}, and \textit{full specification}, respectively. 
\end{abstract}

\section{Introduction}

Features are the substantive building blocks of phonological theory. They represent phonetic qualities of speech sounds, and can be used in isolation or combination to describe individual sounds or classes of sounds \cite<e.g.,>{Saussure1959, JakobsonEtAl1952}.

The goals of feature theory are to capture the following generalizations: \begin{itemize}
  \item segments that are made alike tend to behave alike \begin{itemize}
        \item both within and across languages \end{itemize}
  \item sound change tends to preserve phonetic qualities \begin{itemize}
        \item even when the host segment is altered or destroyed \end{itemize}
  \item featural economy \begin{itemize}
        \item factorial arrangement of segmental inventory \end{itemize}
  \end{itemize}
For example, the English voiceless stops \{p, t, \textipa{\t{tS}}, k\} are all produced with a complete, long-lag closure of the oral cavity, and exactly these segments undergo the process of foot-initial aspiration. The feature notation \phonfeat{-continuant \\ -voiced} exposes these shared phonetic properties to the phonological grammar, and the processes which might reference them. More generally, the set of obstruents within each language tend to undergo similar voicing processes (regressive voicing assimilation within obstruent clusters, word-final devoicing, intervocalic and/or postnasal voicing, etc...). An instance of feature preservation was the fall of the yers in Old Church Slavonic. The front yer (a short, unstressed, high front vowel) deleted in most prosodic positions. However, the preceding consonant became palatalized, thereby preserving the high and front articulations, even while the vowel segment was deleted. \cite{TODO}. TODO: Featural economy

Classic texts \cite<e.g.,>{ChomskyHalle1968} have assumed phonological features are \textit{universal}: all the sounds in the world's languages can be described by the same finite set of features. According to this view, speakers inherently produce and perceive speech in terms of these features, because they are the substantive `atoms' of which segments and higher prosodic constituents are composed. Children represent speech in terms of these atoms, which is why phonological processes operate on the classes they define. Feature theory is manifestly successful in explaining why many common phonological processes involve segments that share relevant phonetic properties.

However, it is also clear that many phonological processes target sets of segments that cannot be singled out by a set of phonetic properties. A canonical example is the \textit{ruki} rule of Sanskrit, in which an underlying /s/ becomes retroflexed when it occurs later in a word than any of \{r, u, k, i\} \cite{TODO}. While it has been proposed that the \textit{ruki} process originated from the distinctive (though not uniform) effects of these segments on the second and third formant of neighboring segments \cite{TODO}, it is widely agreed that no conventional feature system can pick out all four of these segments to the exclusion of others \cite{TODO}. The existence of a single, idiosyncratic rule like this is not grounds for theoretical concern. However, it seems that \textit{phonetically disparate classes} like \{r, u, k, i\} are much more common than would be expected under a universal feature system. \citeA{Mielke2008} conducted a survey of phonological processes in almost 600 languages. Of the classes which underwent or conditioned a phonological process, 71\% could be expressed as a combination of simple features by the `best' feature system he considered. To express the remaining 29\%, additional theoretical mechanisms --  such as building classes through an \textsc{OR} operation -- would be needed. These seriously compromise the explanatory power that made feature theory appealing in the first place. 

The ubiquity of phonetically disparate classes has led some researchers to propose that distinctive features are \textit{learned} and \textit{language-specific} \cite<e.g.,>{Blevins2004, Mielke2008, MacWhinneyOGrady2015, ArchangeliPulleyblank2015}: learners are able to group sounds in their languages into classes, even if they have no phonetic commonality. The striking regularities that exist across languages are explained as by-products of general human cognitive capabilities, such as categorization, sensitivity to frequency, and the ability to generalize, as well as the properties of the human vocal tract and auditory system.

What would the learning system have to look like, in order to accomplish this? One could start with the features and derive classes, or start with the classes and derive features. In this paper, we develop the latter approach. That is, we suppose that some mechanism has identified particular sets of segments as `candidate' classes -- which we refer to as the input. We illustrate how a feature system can be learned from an arbitrary input, i.e. without any reference to the phonetic properties of the segment. We begin by formalizing our notation for feature systems. We then describe the \textit{intersectional closure} of a set of classes, which must be generated by any featurization of that set. Using the intersectional closure as a tool for efficient calculation, we describe a suite of algorithms for learning various types of featurizations for a set of input classes and prove their soundness. Finally, we analyze some tradeoffs between the featurization algorithms, and discuss implications for feature theory and feature learning.

This paper makes several contributions. First, it demonstrates a method for working backwards to feature systems underpinning learned classes of sounds. Second, it provides the code\footnote{https://github.com/rdaland/Pheatures/} for use in future research. Third, it provides a detailed formalization of several featurizations algorithms. This allows careful reasoning about the expressiveness of such featurizations. Finally, by comparing multiple types algorithms, this work makes explicit predictions about what classes should be describable under each type. For example, full specification predicts non-nasal concord is predicted under full specification  to be just as easy to  if  full specification This may be useful for future research, e.g. an artificial grammar learning experiment in which speakers are taught a nasal concord pattern and tested for generalization to non-nasal concord.

\section{Definitions and notation}

Let $\Sigma$ denote an alphabet of segments. We will use the term \textit{class} to mean a subset of $\Sigma$.

\subsection{Classes and class systems}

A \textit{class system} $(\mathcal C, \Sigma)$ consists of an alphabet $\Sigma$ and a set of classes $\mathcal C$ over that alphabet. Over the course of this paper, we will introduce 3 different class systems, which will serve as recurring examples. Here is the first; the class and segment labels are meant to evoke a manner hierarchy:

\vspace{\baselineskip} \noindent \textbf{Example}: Manner hierarchy class system \begin{itemize}
  \item \textit{alphabet} -- \{V, G, L, N, T\}
  \item \textit{sonorants} -- \{V, G, L, N\}
  \item \textit{noncontinuants} -- \{N, T\}
  \item \textit{continuants} -- \{V, G, L\}
  \item \textit{singletons} -- \{V\}, \{G\}, \{L\}, \{N\}, \{T\}
  \end{itemize}

\noindent Fig.~\ref{fig:manner_input} illustrates this class system. Each node corresponds to a class. Downward arrows indicate a \textit{parent/child} relationship.

% show an example of a class system: a manner hierarchy
\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{placeholder.png}
  \caption{A manner hierarchy class system (recurring example).}
  \label{fig:manner_input}
\end{figure}

\vspace{\baselineskip} \noindent The parent/child relationship is of central importance to this work, so we formalize it carefully here.

\vspace{\baselineskip} \noindent \textbf{Definition}: Let $(\mathcal C, \Sigma)$ be a class system. $X \in \mathcal C$ is a \textit{parent} of $Y \in \mathcal C$ (and $Y$ is a \textit{child} of $X$) if and only if \begin{itemize}
    \item $Y \subset X$, and
    \item there exists no $Z \in \mathcal C$ such that $Y \subset Z \subset X$
    \end{itemize}
In other words, $X$ is a parent of $Y$ if a subset/superset relation holds, and there is no `intervening' class. 

In Fig.~\ref{fig:manner_input}, there is a `path' from the alphabet through the sonorants to the continuants. This means the sonorants are a child of the alphabet, and the continuants are a child of the sonorants. The existence of this path implies the continuants are a subset of the alphabet,\footnote{Formally, the subset/superset relation is the \textit{transitive closure} of the parent/child relation, and the parent/child relation is the \textit{transitive reduction} of the subset/superset relation.} but crucially, the continuants are not a child of the alphabet (because the sonorants intervene). It is convenient to depict parent/child relationships (rather than subset/superset) to avoid crowding the graph. But this relation is also important for the featurization algorithms we describe later. We additionally define $\textsc{parents}(Y)$ as the set of classes which are parents of $Y$.

There are some additional aspects of Fig.~\ref{fig:manner_input} which merit comment. First, the empty set is technically a daughter of the singletons (since it is a subset of everything) but it does not appear in the graph. This is because the empty set is a phonologically irrelevant class: it cannot partition the alphabet into segments which undergo a process and those which do not; and to say that it is equivalent to the source or target of a process is equivalent to saying that the process does not happen at all.\footnote{Some confusion may arise with regard to SPE-style rules. In SPE, the null set symbol is used to indicate the source/target of epenthesis/deletion rules. Thus, in SPE the null set symbol is used to denote an \underline{empty string}. In the present work, the null set symbol is used to denote the null set.} Second, the class \{N\} has two dotted arrows which extend to it, rather than a single solid line like the other classes. The dotted lines signify that \{N\} is the intersection of its parents: \{V, G, L, N\} $\cap$ \{N, T\} = \{N\}. As we will prove later, this entails that \{N\} can be expressed as the union of features which express \{V, G, L, N\} and \{N, T\} individually. Therefore, it doesn't need a new feature. We prove later that the opposite is true as well: a class needs a new feature just in case it can't be expressed as the union of features of its parents. This turns out to mean that a class needs a new feature if it has a single parent. However, this statement is not guaranteed to be true for the input class system $\mathcal C$; instead, it holds for a derived class system $\mathcal C_\cap$ we call the intersectional closure. Some careful formalization is necessary to derive these insights.

\subsection{Feature systems and featurizations}

\textbf{Definition}: A \textit{feature system} is a tuple $(\mathcal F, \Sigma, \mathcal V)$ where \begin{itemize}
    \item $\Sigma$ is a segmental alphabet, 
    \item $\mathcal V$ is a set of values, and 
    \item $\mathcal F$ is a \textit{featurization}: a set of features $\{f_j\}_{j=1}^M$, where each feature is a function $f: \Sigma \rightarrow \mathcal V$ mapping segments to feature values
    \end{itemize}

\noindent To illustrate, a possible feature system for the vowel system of Fig.~\ref{fig:manner_input} is shown below in Table~\ref{table:featurization}. In the next subsection we formalize featural descriptors, which relate classes and feature systems.

\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|c|c|}
    \hline
        $\sigma$ & syl & voc & apprx & son \\ \hline
        V & + & + & + & + \\
        G & -- & + & + & + \\
        L & -- & -- & + & + \\
        N & -- & -- & -- & + \\
        T & -- & -- & -- & -- \\
        \hline
    \end{tabular}
    \caption{Example of a feature system.}
    \label{table:featurization}
\end{table}

\subsection{Featural descriptors}

Let $(\mathcal F, \Sigma, \mathcal V)$ be a feature system. We restrict $\mathcal V$ to the following possibilities: \begin{itemize}
    \item \textit{privative specification}: $\mathcal V = \{ +, 0 \}$
    \item \textit{full specification}: $\mathcal V = \{ +, - \}$
    \item \textit{contrastive specification}: $\mathcal V = \{ +, -, 0 \}$
    \end{itemize}

\noindent We will use the notation $\mathcal V_0$ for the set $(\mathcal V \setminus \{0\})$, i.e. the set of non-zero values. This is because zero values are a formal mechanism to achieve underspecification, and the theoretical driver for underspecification is the idea that underspecified features are phonologically inactive (i.e. cannot define classes). Then, a \textit{featural descriptor} $\mathbf{e}$ is a set of feature/value pairs where the values cannot be $0$: i.e. $\mathbf{e} \subset \mathcal V_0 \times \mathcal F$. For example, $\mathbf{e} =$  \phonfeat{+front \\ --low} is a featural descriptor. This is an intensional description of a class; that is, a description of a class in terms of its properties. The extension of a featural descriptor is the set of segments which match (at least) the feature/value pairs in the descriptor. We use angle brackets to indicate this:

$$ \big \langle \mathbf{e} \big \rangle = \{x \in \Sigma \, \mid \, \forall (\alpha_k, f_k) \in \mathbf{e} \text{,  } [ f_k(x) = \alpha_k ] \} $$

\vspace{\baselineskip} \noindent We use the notation $\mathcal V_0^\mathcal F$ to denote the powerset of $\mathcal V_0 \times \mathcal F$, i.e. the set of all licit featural descriptors. Lastly, we define $\langle \mathcal V_0^\mathcal F \rangle = \{ \langle \mathbf{e} \rangle \, \mid \, \mathbf{e} \in \mathcal V_0^\mathcal F \}$, the set of all classes described by some featural descriptor in $\mathcal V_0^\mathcal F$. We say that the feature system $(\mathcal F, \Sigma, \mathcal V)$ generates the class system $\langle \mathcal V_0^\mathcal F \rangle$.

Note that while every featural descriptor in $\mathcal V_0^\mathcal F$ picks out a class in $\langle \mathcal V_0^\mathcal F \rangle$, the two are not generally in 1-1 correspondence. This is because the same class can often be described by multiple featural descriptors. For example, under the the feature system of Table~\ref{table:featurization}, the featural descriptor \phonfeat{+voc} picks out the same class as the featural descriptor \phonfeat{+voc \\ +son}, namely \{V, G\}. Moreover, the featural descriptors \phonfeat{+syl \\ --syl} and \phonfeat{+syl \\ --son} both pick out the empty set.

\vspace{\baselineskip} We say that a feature system $(\mathcal F, \Sigma, \mathcal V)$ \textit{covers} a class system $(\mathcal C, \Sigma)$ if $\mathcal C \subset \langle \mathcal V_0^\mathcal F \rangle$; in other words if the feature system provides a distinct featural representation for every class in $\mathcal C$. In the next subsection, we work an example to illustrate the importance of the value set in featurization.

\subsection{Example: Sonorants and obstruent voicing}

In this subsection we introduce a simple, 3-segment class system to illustrate the notation, as well as the difference between privative and full specifiation.

Let $\Sigma =$ \{R, D, T\}, where $R$ is meant to evoke a sonorant, $D$ a voiced obstruent, and $T$ a voiceless obstruent. Accordingly we use the feature names $vcd$ and $son$, but note that these descriptive labels are purely for the reader's convenience. We begin with the privative featurization in Table~\ref{table:privative}.

% table with featurization of sonorants, voiced obstruents, and voiceless obstruents
\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|}
    \hline
        $\sigma$ & son & vcd \\ \hline
        R & + & + \\
        D & 0 & + \\
        T & 0 & 0 \\
        \hline
    \end{tabular}
    \caption{Sonorants and obstruents with privative specification.}
    \label{table:privative}
\end{table}

\noindent The set of classes it describes, and the simplest featural descriptor for each, are shown below: \begin{itemize}
  \item $\langle \, [\,] \, \rangle = $ \{R, D, T\}
  \item $\langle \, [+\text{son}] \, \rangle$ = \{R\}
  \item $\langle \, [+\text{vcd}] \, \rangle$ = \{R, D\}
  \end{itemize}
  
\noindent Note that this featurization provides (i) no featural descriptor that uniquely picks out the voiceless obstruent \{T\}, (ii) no way to pick out the obstruents \{T\} and \{D\} to the exclusion of \{R\}, and (iii) no way to pick out the voiced obstruent \{D\} without \{R\}.

Next, consider the featurization in which the `$0$'s from Table~\ref{table:privative} are replaced with `$-$'s (full specification):

% table with featurization of sonorants, voiced obstruents, and voiceless obstruents
\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|}
    \hline
        $\sigma$ & son & vcd \\ \hline
        R & + & + \\
        D & -- & + \\
        T & -- & -- \\
        \hline
    \end{tabular}
    \caption{Sonorants and obstruents with full specification.}
    \label{table:full}
\end{table}

\noindent This featurization is more expressive than the last one: \begin{itemize}
    \item $\langle \, [\,] \, \rangle =$ \{R, D, T\}
    \item $\langle \, [+\text{son}] \, \rangle =$ \{R\}
    \item $\langle \, [-\text{son}] \, \rangle =$ \{D, T\}
    \item $\langle \, [+\text{vcd}] \, \rangle =$ \{R, D\}
    \item $\langle \, [-\text{vcd}]  \, \rangle=$ \{T\}
    \item $\langle \, [-\text{son},+\text{vcd}] \, \rangle =$ \{D\}
    \item $\langle \, [+\text{son},-\text{vcd}] \, \rangle = \varnothing$
    \end{itemize}

\vspace{\baselineskip} \noindent While the privative featurization just covers three classes, the full specification featurization covers six (not counting the null set). The ability for featural descriptors to refer to `--' values provides a greater number of ways to `slice and dice' the alphabet. It follows that featurizations which assign more `$0$' values generally require more distinct feature functions to cover the same class system.

\vspace{\baselineskip} In the next section, we introduce the notion of intersectional closure. This data structure will prove essential for efficiently assigning feature systems.

\section{Intersectional closure}

In this section we define the \textit{intersectional closure} of a class system $\mathcal{C}$ as the set of classes that can be generated by intersecting $\Sigma$ with an arbitrary subset of classes in $\mathcal{C}$. We relate the intersectional closure to features by showing that if a feature system is expressive enough to generate all the classes in $\mathcal{C}$, it generates the intersectional closure. Then we give a dynamic programming algorithm which efficiently computes the intersectional closure. 

\subsection{Definitions}

\textbf{Definition}: A collection of sets $\mathcal C$ is \textit{intersectionally closed} if and only if for all $X \in \mathcal C$ and $Y \in \mathcal C$, $X \cap Y \in \mathcal C$.

\vspace{\baselineskip} \noindent The \textit{intersectional closure} of a class system $(\mathcal C, \Sigma)$, written $\mathcal C_\cap$, is the smallest intersectionally closed class system which contains $\mathcal C$ and $\Sigma$.

\vspace{\baselineskip} \noindent \textbf{Definition}: $\mathcal C_\cap = \{ \, \big( \bigcap_{X_i \in P} X_i \big) \, \mid \, P \in \mathcal P(\mathcal C \cup \{ \Sigma \}) \}$ where $\mathcal P(\cdot)$ is the powerset operator. 

\vspace{\baselineskip} \noindent In other words, the intersectional closure contains every class which can be generated by finite intersections of classes from $\mathcal C$ (and $\Sigma$), and no other classes besides these.

To illustrate this concept, we introduce a final example, the vowel inventory in Table~\ref{table:vowel_inventory}.

\begin{table}[h]
    \centering
    \begin{tabular} {|c|c|c|c|}
    \hline
                 &            front                   & mid           & back         \\ \hline
         high & \textipa{i} \textipa{y}      &                  & \textipa{u} \\
         mid  & \textipa{E} \textipa{\oe} &                  & \textipa{o} \\
         low  &                                       & \textipa{a} &                  \\ \hline
    \end{tabular}
    \caption{Vowel inventory}
    \label{table:vowel_inventory}
\end{table}

\vspace{\baselineskip} \noindent Let $(\mathcal C, \Sigma)$ consist of the following classes: \begin{itemize}
  \item \textit{alphabet} -- \{\textipa{i}, \textipa{y}, \textipa{u}, \textipa{E}, \textipa{\oe}, \textipa{o}\, \textipa{a}\} 
  \item \textit{high} -- \{\textipa{i}, \textipa{y}, \textipa{u}\}
  \item \textit{front} -- \{\textipa{i}, \textipa{y}, \textipa{E}, \textipa{\oe}\}
  \item \textit{round} -- \{\textipa{y}, \textipa{u}, \textipa{\oe}, \textipa{o}\}
  \item \textit{singletons} -- \{\textipa{i}\}, \{\textipa{y}\}, \{\textipa{u}\}, \{\textipa{E}\}, \{\textipa{\oe}\}, \{\textipa{o}\}, \{\textipa{a}\}
  \end{itemize}

\vspace{\baselineskip} \noindent $\mathcal C$ is depicted in Fig.~\ref{fig:vowel_inventory}; the intersectional closure $\mathcal C_\cap$ is depicted in Fig.~\ref{fig:vowel_inventory_closure}. The difference between the two is highlighted by using red boxes for the `extra' classes.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{placeholder.png}
  \caption{A vowel inventory.}
  \label{fig:vowel_inventory}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{placeholder.png}
  \caption{Intersectional closure of the vowel inventory.}
  \label{fig:vowel_inventory_closure}
\end{figure}

The key difference is that the intersectional closure contains 2-segment classes which are the intersection of larger classes. For example, the \textit{high, front} class \{\textipa{i}, \textipa{y}\} is the intersection of the \textit{high} class and the \textit{front} class:

$$ \text{\{\textipa{i}, \textipa{y}\}} = \text{\{\textipa{i}, \textipa{y}, \textipa{u}\}} \cap \text{\{\textipa{i}, \textipa{y}, \textipa{E}, \textipa{\oe}\}} $$

\vspace{\baselineskip} \noindent Note that the high, front, round class \{\textipa{y}\} has dotted lines because it is the intersection of the high/front, front/round, and high/round classes. In the next subsection, we prove that featurizations must cover intersectional closures, i.e. if a featurization is expressive enough to cover $\mathcal C$, it covers $\mathcal C_\cap$.

\subsection{Feature systems generate an intersectional closure}

There is a dual relationship between featural descriptors and the classes they describe: intersection of classes corresponds to union of featural descriptors. We formalize this property with the following lemma.

\vspace{\baselineskip} \noindent \textbf{Featural Intersection Lemma}

Let $(\mathcal F, \Sigma, \mathcal V)$ be a feature system. If $\mathbf{e}_i, \mathbf{e}_j \in \mathcal V_0^\mathcal F$, then $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle =  \langle \mathbf{e}_i \rangle \cap \langle \mathbf{e}_j \rangle$.

\vspace{\baselineskip} \noindent \textit{Proof}:

The proof proceeds by showing that $ \langle \mathbf{e}_i \rangle \cap \langle \mathbf{e}_j \rangle \subset \langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$ and $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle \subset  \langle \mathbf{e}_i \rangle \cap \langle \mathbf{e}_j \rangle$.
Let $C_i = \langle \mathbf{e}_i \rangle$ and $C_j = \langle \mathbf{e}_j \rangle$.
First, suppose $x \in C_i \cap C_j$. Then $x \in C_i$. By definition, $x$ must have the features in $\mathbf{e}_i$.
Similarly, $x \in C_j$, and therefore must have the features in $\mathbf{e}_j$.
Thus, $x$ has the features in $\mathbf{e}_i \cup \mathbf{e}_j$. This shows that $C_i \cap C_j \subset \langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$.
Now, suppose $x \in \langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$. Then $x$ has all the features of $\mathbf{e}_i$, and so $x \in C_i$.
Similarly, $x$ has all the features of $\mathbf{e}_j$, so $x \in C_j$. Therefore $x \in C_i \cap C_j$. This shows that $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle \subset C_i \cap C_j$.
Since both $C_i \cap C_j$ and $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$ are subsets of each other, they are equal.
This completes the proof.

\vspace{\baselineskip} We illustrate this lemma with reference to the vowel inventory system introduced above. For concreteness, let us adopt the following featurization:

% table with featurization of sonorants, voiced obstruents, and voiceless obstruents
\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|c|c|}
    \hline
        $\sigma$      & nonlow & front & round & high \\ \hline
        \textipa{i}      & +          & +      & 0        & +      \\
        \textipa{E}    & +          & +      & 0         & --      \\
        \textipa{\oe} & +          & +      & +         & --      \\
        \textipa{y}    & +          & +      & +         & +       \\
        \textipa{u}    & +          & --      & +         & +      \\
        \textipa{o}    & +          & --      & +         & --      \\
        \textipa{a}    & --          & 0      & 0         & 0       \\ \hline
    \end{tabular}
    \caption{A featurization of the vowel inventory. The low vowel is unspecified for front/round/high features; the round feature is privative.}
    \label{table:vowel_inventory_underspec}
\end{table}

\vspace{\baselineskip} \noindent Let $\mathbf{e}_1 =$ \phonfeat{+front} and $\mathbf{e}_2 =$ \phonfeat{+round}. Then we have: \begin{itemize}
    \item $\langle \mathbf{e}_1 \rangle = \langle$\phonfeat{+front}$\rangle =$ \{\textipa{\oe}, \textipa{y}, \textipa{E}, \textipa{i}\}
    \item $\langle \mathbf{e}_2 \rangle = \langle$\phonfeat{+round}$\rangle =$ \{\textipa{\oe}, \textipa{o}, \textipa{y}, \textipa{u}\}
    \end{itemize}
\noindent For these values, the Featural Intersection Lemma cashes out as follows: `the set of vowels that are both front and round' is the intersection of `the set of vowels that are front' and `the set of vowels that are round': \begin{itemize}
    \item $\langle \mathbf{e}_1 \rangle \cap \langle \mathbf{e}_2 \rangle =  \langle$\phonfeat{+front}$\rangle \cap \langle$\phonfeat{+round}$\rangle =$ \{\textipa{\oe}, \textipa{y}, \textipa{E}, \textipa{i}\} $\cap$ \{\textipa{\oe}, \textipa{o}, \textipa{y}, \textipa{u}\} = \{\textipa{\oe}, \textipa{y}\}
    \item $\langle \mathbf{e}_1 \cup \mathbf{e}_2 \rangle = \langle$\phonfeat{+front,+round}$\rangle =$ \{\textipa{\oe}, \textipa{y}\}
    \end{itemize}

\noindent The Featural Intersection Lemma proves that this kind of relationship holds for any pair of featural descriptors and the classes they describe.

An important consequence of this lemma is that it can be applied inductively, to relate the union of multiple featural descriptors with the intersection of multiple classes. Because the intersectional closure is defined as the intersection of arbitrarily many classes in an input $\mathcal C$, the Featural Intersection Lemma ends up entailing that if a featurization covers $\mathcal C$, it must cover the intersectional closure.

\vspace{\baselineskip} \noindent \textbf{Intersectional Closure Covering Theorem}

Let $(\mathcal C, \Sigma)$ be a class system and $(\mathcal F, \Sigma, \mathcal V)$ a feature set. If $\mathcal C \subset \langle \mathcal V_0^\mathcal F \rangle$, then $\mathcal C_\cap \subset\langle \mathcal V_0^\mathcal F \rangle $.

\vspace{\baselineskip} \noindent \textit{Proof}:

Let $Y$ be an arbitrary class in $\mathcal C_\cap$. By definition of $\mathcal C_\cap$, there exist $\{X_i \in \mathcal C\}_{i \in I}$ (for some index set $I$, hereafter omitted) such that and $Y = \bigcap_i \, X_i$. The hypothesis that $\mathcal C \subset \langle \mathcal V_0^\mathcal F \rangle $ implies that for every such $X_i$, there exists a featural descriptor $\mathbf{e}_i$ such that $\langle \mathbf{e}_i \rangle = X_i$. Thus, $Y = \bigcap_i X_i = X_1 \cap X_2 \cap \ldots \cap X_n$ can also be written $C = \bigcap_i \, \langle \mathbf{e}_i \rangle = \langle \mathbf{e}_1 \rangle \cap \langle \mathbf{e}_2 \rangle \cap \ldots \cap \langle \mathbf{e}_n \rangle$. It follows by induction using Featural Intersection Lemma that $Y = \langle \bigcup_i \mathbf{e}_i \rangle$:

$Y = \langle \mathbf{e}_1 \rangle \cap  \langle \mathbf{e}_2 \rangle \cap \ldots \cap  \langle \mathbf{e}_n \rangle$

\quad $ = \langle \mathbf{e}_1 \cup \mathbf{e}_2 \rangle \cap \mathbf{e}_3 \cap \ldots \cap \langle \mathbf{e}_n \rangle$

\quad $ = \langle \mathbf{e}_1 \cup \mathbf{e}_2 \cup \mathbf{e}_3 \rangle \cap \ldots \cap \langle \mathbf{e}_n \rangle$

\quad $\ldots$

\quad $= \langle \mathbf{e}_1 \cup \mathbf{e}_2 \cup \ldots \cup \mathbf{e}_n \rangle$

\quad $= \langle \bigcup_i  \mathbf{e}_i \rangle$

\vspace{\baselineskip} \noindent The preceding chain of logic demonstrates the following fact: if a class can be expressed as the intersection of classes in $\mathcal C$, then its features are the union of the features in each of those classes. The intersectional closure is defined as all possible intersections of classes in $\mathcal C$. Thus, if $(\mathcal F, \Sigma, \mathcal V)$ covers $\mathcal C$, it covers the intersectional closure. This completes the proof.

Having illustrated the formal notation for features and the notion of intersectional closure, we turn now to a dynamic programming algorithm for efficiently calculating the intersectional closure.

\subsection{An algorithm for calculating the intersectional closure}

The following algorithm yields the intersectional closure of a class system $(\mathcal C, \Sigma)$. It bears a close resemblance to Dijkstra's shortest-paths algorithm; a proof of soundness is given in the Appendix.

\noindent \begin{algorithmic}
    \ENSURE $\mathcal C_\cap$ is the intersectional closure of the input $\mathcal C$
    \STATE
    \STATE $\mathcal C_\cap \leftarrow \{ \Sigma \} $
    \STATE $\mathcal Q \leftarrow \mathcal C$
    \STATE
    \WHILE{$\mathcal Q \neq \varnothing$}
        \STATE $X \leftarrow \textsc{dequeue}(\mathcal Q)$
        \IF{\NOT $X \in \mathcal C_\cap$}
            \FOR{$Y \in \mathcal C_\cap$}
                \STATE $\textsc{enqueue}(\mathcal Q, X \cap Y)$
            \ENDFOR
            \STATE $\textsc{append}(\mathcal C_\cap, \, X)$
        \ENDIF
    \ENDWHILE
\end{algorithmic}


\subsection{Parenthood in the intersectional closure}

As we will see shortly, the advantage of explicitly computing the intersectional closure is that \textit{a new feature is required for all and only the classes which have a single parent in the intersectional closure}. The core reason for this is that if a class has two parents, it must be their intersection. We prove this here.

\vspace{\baselineskip} \noindent \textbf{Single Parenthood Theorem}

Let $(\mathcal C, \Sigma)$ be a class system and $Y \in \mathcal C_\cap$. If $X_1, X_2 \in \textsc{parents}(Y)$, then $Y = X_1 \cap X_2$.

\vspace{\baselineskip} \noindent \textit{Proof}:

First, observe that $Y \subset X_1 \cap X_2$. This follows trivially from the definition of parenthood: $X_1$ is a parent of $Y$ implies $Y \subset X_1$, $X_2$ is a parent of $Y$ implies $Y \subset X_2$, and so every element in $Y$ is in both $X_1$ and $X_2$.

Now suppose that $X_1 \cap X_2 \neq Y$. The preceding logic showed that either the two are equal, or $Y$ is a proper subset of $X_1 \cap X_2$. But the latter case creates a contradiction. By definition, $(X_1 \cap X_2)$ must be in the intersectional closure, and $X_1 \cap X_2 \subset X_1$ follows from fundamental properties of sets. Then $X_1 \cap X_2$ intervenes between $Y$ and $X_1$, contradicting the hypothesis that $Y$ is a daughter of $X_1$. Thus, $Y = X_1 \cap X_2$.
	
\vspace{\baselineskip} Note that the Single Parenthood Theorem does not logically exclude the possibility that a class may have more than two parents. Rather, it guarantees that in such cases, the intersection is the same regardless of how many parents are considered. One case in which this can happen is the null set: if $x, y, z$ are three distinct elements from $\Sigma$, then $\{ x \} \cap \{ y \} = \varnothing = \{ y \} \cap \{ z \}$. A more interesting case arose already in Fig.~\ref{fig:vowel_inventory_closure}, the intersectional closure of the vowel inventory. There, the three features \textit{front}, \textit{high}, and \textit{round} give rise to three distinct 2-feature classes (featural descriptors: \phonfeat{+front \\ +high}, \phonfeat{+high \\ +round}, \phonfeat{+round \\ +front}). The intersection of any pair of these is \{\textipa{y}\} (the high, front, round vowel). Thus, the set  \{\textipa{y}\} has 3 parents, but which segments it contains is uniquely determined by any pair of them.

In the next section, we give an algorithm which generates a privative feature system that covers the intersectional closure $\mathcal C_\cap$, given the input of a class system $(\mathcal C, \Sigma)$.

 \section{Privative specification}

% TODO: Really a rough transition from the previous section into here
The following algorithm yields a privative specification by assigning a different feature \phonfeat{+f} to the segments in each class with a single parent.
 
\noindent \begin{algorithmic}
    \REQUIRE $\mathcal C_\cap$ is the intersectional closure of a class system $(\mathcal C, \Sigma)$
    \ENSURE $\mathcal F$ is a featurization over $\mathcal V = \{ +, 0 \}$ which covers $\mathcal C$
    \STATE
    \STATE $\mathcal Q \leftarrow \mathcal C_\cap$
    \STATE $\mathcal F \leftarrow \varnothing$
    \STATE
    \WHILE{$\mathcal Q \neq \varnothing$}
        \STATE $X \leftarrow \textsc{pop}(\mathcal Q)$
        \IF{$|\textsc{parents}(X)| = 1$}
            \STATE define $f_X : \Sigma \rightarrow \mathcal V$ by $f_X(\sigma) = \begin{cases}
                + & \mbox{if } \sigma \in X \\
                0 & \mbox{otherwise}
                \end{cases} $
            \STATE $\textsc{append}(\mathcal F, f_X)$
        \ENDIF
    \ENDWHILE
\end{algorithmic}

\vspace{\baselineskip} \noindent \textit{Proof of soundness for the privative specification algorithm}

A featurization algorithm is \textit{sound} if for every class system $(\mathcal C, \Sigma)$, it returns a feature system which covers $\mathcal C$. To see that the privative specification algorithm is sound, note that every class in $\mathcal C_\cap$ enters the queue $\mathcal Q$. For an arbitrary class $X$ in the queue, there are 3 cases. If $X$ has 0 parents, then it is $\Sigma$, and is covered by the empty featural descriptor. If $X$ has exactly 1 parent, then the segments in $X$ get the features of that parent (which uniquely pick out the parent class), plus a new feature $f$ which distinguishes the segments in $X$ from $X$'s parent. If $X$ has more than 1 parent, then Single Parenthood Theorem shows, via the Featural Intersection Lemma, that the union of features of $X$'s parents uniquely pick out all and only the segments in $X$. Thus, each class which exits the queue has a set of features assigned to its segments which pick out that class uniquely. This completes the proof.

\vspace{\baselineskip} In Fig.~\ref{fig:privative}, we illustrate the outcome of applying the privative specification algorithm to the (intersectional closure of the) vowel class inventory shown in Fig.~\ref{fig:vowel_inventory_closure}. We employ several conventions to jointly optimize readability and informativity. First, classes which have a single parent are visually highlighted using a thick, red border. These represent the classes that cannot be featurized simply by the union of their parents' features. Second, the arrow which leads to each such class is annotated with the feature/value pair that is used to distinguish it. This represents the `point' at which each feature is assigned. This could give the misleading impression that features are assigned to classes; so it is worth reinforcing here that features are maps from \textit{segments} to values. As a consequence, when the algorithm assigns a feature/value pairs to every segment in a class, the feature/value pair is automatically inherited by every descendant of the class. The set of features that is shared by all members of a class is represented under the node. The complete featurization assigned to each segment is thus represented by inspecting the singleton sets in the bottom row. For readability, we use feature names that are familiar from phonological theory when the feature picks out more than segment in isolation (but note that the algorithm knows nothing of phonetic substance -- as far as it is concerned, they are just arbitrary symbols). When the feature only picks out one segment, we name the feature after the segment.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{placeholder.png}
  \caption{Yield of the privative specification algorithm.}
  \label{fig:privative}
\end{figure}

We close this section with some observations on the properties of the privative specification algorithm and the featurization it yields. 

\subsection{Properties of privative specification}

One point to observe is that the privative specification algorithm is \textit{maximally conservative}. What we mean by this is that the resulting feature system generates the smallest class system that covers $\mathcal C$. As the Intersectional Closure Covering Theorem showed, any featurization which covers $\mathcal C$ will cover $\mathcal C_\cap$. This means that any classes which are the intersection of input classes, but which were not themselves in the input, will be `accessible' to the output feature system. But the privative specification algorithm will not make it possible to refer to any other classes outside the intersectional closure. For example, if the input contains a \phonfeat{+front} class and a \phonfeat{+round} class, it must generate a \phonfeat{+front \\ +round} class, but it will not `create' a \phonfeat{--round} class.

This might be the desired behavior. But other properties might be desired instead. For instance, one might have theoretical grounds for wishing to allow `$-$' values. One might also wish to have an \textit{efficient} feature system -- one which minimizes the number of features needed to cover $\mathcal C$. It is easy to show that one can sometimes achieve a more efficient feature system by `adding' classes to the system. For example, the featurization shown in Fig.~\ref{fig:privative} contains 10 features (\textit{front}, \textit{high}, \textit{round}, plus 7 features for the individual segments that cannot be accessed as combinations of front, high, and round). It is left as an exercise for the reader to verify that if the input consists of the following classes, the privative specification algorithm returns a featurization with 7 features: \begin{itemize}
    \item \textit{front} -- \{\textipa{i}, \textipa{y}, \textipa{E}, \textipa{\oe}\}
    \item \textit{back} -- \{\textipa{u}, \textipa{o}\}
    \item \textit{round} -- \{\textipa{y}, \textipa{u}, \textipa{\oe}, \textipa{o}\}
    \item \textit{unround} -- \{\textipa{i}, \textipa{E}, \textipa{a}\}
    \item \textit{high} --  \{\textipa{i}, \textipa{y}, \textipa{u}\}
    \item \textit{low} -- \{\textipa{a}\}
    \item \textit{mid} --  \{\textipa{E}, \textipa{\oe}, \textipa{o}\}
    \end{itemize}
Crucially, this featurization covers the original class system shown in Fig.~\ref{fig:vowel_inventory}. Thus, it uses fewer features while generating a richer class system.

This example is presented to make two points. First, the relationship between classes in the input and the specification algorithm is not monotone. In general, adding features to a system will make more classes accessible -- but in this example, a smaller number of features covers a larger class system. Thus, the minimal number of features needed to cover $\mathcal C$ is not predictable from a `simple' property, such as the total number of classes in $\mathcal C$. To be more precise, the proof of soundness of the privative specification algorithm gives an upper bound on the features needed to cover a class system (namely, the number of classes in the intersectional closure with a single parent). We return to the issue of feature efficiency and expressiveness in the Discussion section. In the meantime, we turn to the second point this example makes -- adding the `right' classes to the input is what enabled a more economical feature system. In the next sections, we explore variants of the privative specification algorithm which consider complement classes and assign `$-$' values instead of (or in addition to) `$0$' values. 

\section{Contrastive underspecification}

One of the best cases for non-privative specifications arise from complement classes, such as round vs. nonround vowels, or voiced vs. voiceless obstruents. In a language with rounding harmony, like Turkish, one would need to write one harmony rule for the \phonfeat{+round} feature, and an otherwise identical rule for the \phonfeat{+nonround} feature. By allowing features to take on opposing values, one formally recognizes the sameness of rounding with respect to the harmony process.

In canonical cases like rounding harmony and voicing assimilation, the binary feature is only relevant for certain segments. For example, in the case of rounding harmony, it is normally useful to assign the \phonfeat{+round} and \phonfeat{-round} values only to vowels. In some languages, one might wish to only assign these values to just non-low vowels, or just front vowels. In all such cases, the contrasting feature values denote complementary classes -- but complements with respect to \textit{what}?

The central insight developed in this paper is that a new feature needs to be assigned just in case a class has a single parent. This suggests that a relevant domain for complementation is with respect to the parent. This is the distinction between privative specification and contrastive underspecification: a `$-$' value is assigned when the complement of the class being processed with respect to its parent is in the input.

\vspace{\baselineskip} \noindent \begin{algorithmic}
    \REQUIRE $\mathcal C_\cap$ is the intersectional closure of input class system $(\mathcal C, \Sigma)$
    \ENSURE $\mathcal F$ is a featurization over $\mathcal V = \{ +, -, 0 \}$ which covers $\mathcal C$
    \STATE
    \STATE $\mathcal Q \leftarrow \mathcal C_\cap$
    \STATE $\mathcal F \leftarrow \varnothing$
    \STATE
    \WHILE{$\mathcal Q \neq \varnothing$}
        \STATE $X \leftarrow \textsc{dequeue}(\mathcal Q)$
        \IF{$| \textsc{parents}(X) | = 1$}
            \STATE $P_X \leftarrow \textsc{dequeue}(\textsc{parents}(X))$
            \STATE
            \STATE $\overline{X} \leftarrow \begin{cases}
                P_X \setminus X & \text{if } (P_X \setminus X) \in \mathcal C \\
                \varnothing     & \text{otherwise}
                \end{cases}$
            \STATE
            \STATE define $f_X : \Sigma \rightarrow \mathcal V$ by $f_X (\sigma) = \begin{cases}
                    + & \text{if } \sigma \in X \\
                    - & \text{if } \sigma \in \overline{X} \\
                    0 & \text{otherwise}
                    \end{cases}$
            \STATE $\textsc{append}(\mathcal F, f_X)$
        \ENDIF
    \ENDWHILE
\end{algorithmic}

\vspace{\baselineskip} \noindent The soundness of this algorithm follows from the soundness of the privative specification algorithm. That is because the contrastive underspecification algorithm yields a feature system which generates the same class system as privative specification does. The difference between the two is that if the input contains complement sets, then contrastive underspecification will use a single feature with `$+$' and `$-$' values, where privative specification will have two features with just `$+$' values.

\vspace{\baselineskip} We illustrate this algorithm on the 3-segment system \{R, T, D\} discussed before. Suppose that the input consists of the following: \begin{itemize}
    \item \textit{obstruents} -- \{D, T\}
    \item \textit{sonorants} -- \{R\}
    \item \textit{voiced obstruents} -- \{D\}
    \item \textit{voiceless obstruents} -- \{T\}
    \end{itemize}

\noindent Then contrastive underspecification will yield the following featurization (or one which is equivalent to it, but with inverse signs):

% table with featurization of sonorants, voiced obstruents, and voiceless obstruents
\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|}
    \hline
        $\sigma$ & obstr & vcd \\ \hline
        R & -- & 0 \\
        D & + & + \\
        T & + & -- \\
        \hline
    \end{tabular}
    \caption{Sonorants and obstruents with contrastive underspecification.}
    \label{table:underspecification}
\end{table}

The term \textit{contrastive underspecification} is meant to capture that features can be binary or privative. Segments will be underspecified with respect to a feature if the relevant complement class is not included in the input. For example, in Table~\ref{table:underspecification} the segment $R$ is not specified for voicing -- but it would have been if the input had included the class \{R, D\}. In the next section, we consider a variant of the algorithm which adds the complement class, even if it wasn't present in the input. We call this variant \textit{contrastive specification}.
    
\section{Contrastive specification}

Contrastive specification is very similar to contrastive underspecification. The key difference is that contrastive specification adds complements (with respect to the parent) to the covering. Every complement gets a `$-$' feature, including those which were not in the input. This can result in adding classes that are not in the intersectional closure of the input. One way to address this is to update the intersectional closure dynamically. However, it is also possible to precompute the result (because the classes that must be added can be defined in terms of subset/superset relations, which do not depend on features); we do this as it is conceptually simpler. The algorithm is called \textsc{AddComplementsContrastive} (a proof is given in the Appendix). An additional difference between this featurization and the previous two is that the ordering in which classes are processed matters. Breadth-first search -- processing all the siblings of a class before its children -- is done to avoid configurations that duplicate a feature.

\vspace{\baselineskip} \noindent \begin{algorithmic}
    \REQUIRE $\mathcal C_\cap$ is the intersectional closure of input class system $(\mathcal C, \Sigma)$
    \ENSURE $\mathcal F$ is a featurization over $\mathcal V = \{ +, -, 0 \}$ which covers $\mathcal C$
    \STATE
    \STATE $\mathcal Q \leftarrow \textsc{AddComplementsContrastive}(\mathcal{C_\cap})$
    \STATE $\mathcal F \leftarrow \varnothing$
    \STATE
    \WHILE{$\mathcal Q \neq \varnothing$}
        \STATE $X \leftarrow \textsc{dequeue}(\mathcal Q)$
        \IF{$| \textsc{parents}(X) | = 1$}
            \STATE $P_X \leftarrow \textsc{dequeue}(\textsc{parents}(X))$
            \STATE $\overline{X} \leftarrow P_X \setminus X$
            \STATE define $f_X : \Sigma \rightarrow \mathcal V$ by $f_X (\sigma) = \begin{cases}
                    + & \text{if } \sigma \in X \\
                    - & \text{if } \sigma \in \overline{X} \\
                    0 & \text{otherwise}
                    \end{cases}$
            \STATE $\textsc{append}(\mathcal F, f_X)$
            \STATE $\textsc{remove}(\mathcal{Q}, \overline{X})$
        \ENDIF
    \ENDWHILE
\end{algorithmic}

\vspace{\baselineskip} \noindent This algorithm is sound because it considers all the classes that the privative specification algorithm does, plus others. Thus, it necessarily covers $\mathcal C$.

\vspace{\baselineskip} Fig.~\ref{fig:contrastive} illustrates the contrastive specification algorithm using the manner hierarchy.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{placeholder.png}
  \caption{Class system and featurization yielded by contrastive specification.}
  \label{fig:contrastive}
\end{figure}

\noindent Note that the feature system yielded by contrastive specification is much more expressive than the one yielded by privative specification. However, it is still not maximally expressive, since it still contains `$0$' values. When a new feature is added, non-zero values are added only to classes that are descendants of the parent of the class that generates the new feature. For example, suppose that stridents are daughters of coronals, and coronals are daughters of $\Sigma$. Then contrastive specification will create a \phonfeat{--coronal} class (all noncoronals) and a \phonfeat{--strident} class. The latter class will include all coronal nonstridents, but it will not include labials or other noncoronal nonstridents. Thus, while the \textit{coronal} feature assigns a `$+$' or `$-$' value to every segment, the \textit{strident} feature assigns a `$0$' value to noncoronals. If it is desired to eliminate all `$0$' values, one can do complementation with respect to $\Sigma$ rather than the single parent. That is the final variant we discuss -- full specification.

\section{Full specification}

Full specification differs from contrastive specification in that complementation is calculated with respect to the whole alphabet, rather than the parent class. Therefore, it is algorithmically almost the same as contrastive specification. As with contrastive specification, the intersectional closure is precomputed (\textsc{AddComplementsFull}: see Appendix).

\vspace{\baselineskip} \noindent \begin{algorithmic}
    \REQUIRE $\mathcal C_\cap$ is the intersectional closure of input class system $(\mathcal C, \Sigma)$
    \ENSURE $\mathcal F$ is a featurization over $\mathcal V = \{ +, - \}$ which covers $\mathcal C$
    \STATE
    \STATE $\mathcal Q \leftarrow \textsc{AddComplementsFull}(\mathcal{C_\cap})$
    \STATE $\mathcal F \leftarrow \varnothing$
    \STATE
    \WHILE{$\mathcal Q \neq \varnothing$}
        \STATE $X \leftarrow \textsc{dequeue}(\mathcal Q)$
        \IF{$| \textsc{parents}(X) | = 1$}
	        \STATE $\overline{X} \leftarrow \Sigma \setminus X$
            \STATE define $f_X : \Sigma \rightarrow \mathcal V$ by $f_X (\sigma) = \begin{cases}
                    + & \text{if } \sigma \in X \\
                    - & \text{otherwise}
                    \end{cases}$
            \STATE $\textsc{append}(\mathcal F, f_X)$
            \STATE $\textsc{remove}(\mathcal{Q}, \overline{X})$
        \ENDIF
    \ENDWHILE
\end{algorithmic}

\vspace{\baselineskip} \noindent The full specification algorithm is sound for the same reason that the contrastive specification algorithm is -- it considers a superset of classes that the privative specification algorithm does, and thus it covers the input.

\vspace{\baselineskip} The key way in which full specification differs from contrastive specification is that no privative specification can occur whatsoever. For example, if a single feature \phonfeat{+nasal} is used to pick out nasal segments, then the feature system will also generate the class \phonfeat{--nasal} consisting of all non-nasal segments. According to our understanding of nasal typology, this is probably not the desired behavior for the nasal feature \cite{TODO}. However, it is possible to avoid generating a \phonfeat{--nasal} class by ensuring that the nasals are generated as the union of pre-existing features, rather than needing their own feature. For example, if \phonfeat{--continuant} picks out the nasals and oral stops, while \phonfeat{+sonorant} picks out vowels, glides, liquids, and nasals, then the nasal class is picked out by \phonfeat{-continuant \\ +sonorant}. Therefore, the set of all non-nasals is not generated as a complement class. A desirable property of this solution is that the following classes fall out: continuant non-sonorants (fricatives), continuant sonorants (approximants), and non-continuant non-sonorants (stops and affricates). Less desirably, this solution fails to transparently represent nasal spreading processes; for example, vowel nasalization cannot be described as continuancy or sonorancy assimilation. Thus, the cross-linguistic behavior and learnability of classes like \phonfeat{--nasal} has the potential to inform feature theory. We take up this and other issues in the Discussion.

\section{Discussion}

In this paper, we have given a number of algorithms which assign a featurization to a set of classes, such that every class in the input can be picked out by a featural description. We gave several variants of the algorithm, differing in how conservative they are with respect to the input. The most conservative algorithm assigns a privative specification, i.e. feature functions which only pick out positively specified elements. Contrastive underspecification is achieved with the same algorithm, except that a negative specification is assigned just in case the complement of a class (with respect to the parent class) is in the input. Contrastive specification is similar, except that a negative specification is assigned even if the complement (with respect to the parent) was not in the input. Full specification is similar to contrastive specification, except the complement is taken with respect to the entire segmental alphabet. In this section, we discuss some outstanding issues, such as feature economy, how the current work bears on feature theory, and applications toward a richer theory of feature learning.

\subsection{Feature efficiency and expressivity}

Here we present some examples which illustrate a little more about the expressiveness of class systems.

Let $\mathcal C = \{ \{\sigma\} \, | \, \sigma \in \Sigma \}$; that is, the input consists of all and only the singleton sets. For convenience, we will refer to this as the \textit{singleton input}. Consider what happens when the privative specification algorithm is run on the singleton input. It will yield a featurization with $n$ features, where $n$ is the cardinality of $\Sigma$, and this is because each segment gets its own feature. This featurization will only generate the classes in the input (and $\Sigma$, and $\varnothing$).

The opposite extreme is obtained by the \textit{singleton complement} input -- where the input consists not of all singleton sets, but the complement of each singleton set:  $\mathcal C = \{ \Sigma \setminus \{\sigma\} \, | \, \sigma \in \Sigma \}$. It is left as an exercise for the reader to show that when the privative specification algorithm is given this input, it generates the full powerset of $\Sigma$ -- every possible subset gets a unique combination of features. Thus, privative specification is still compatible with a maximally expressive system.

The powerset of $\Sigma$ is also generated by running the full specification algorithm on the singleton input. Thus, there are cases where a more conservative algorithm yields the same class system as a less conservative algorithm. In fact, it is generally true that the more conservative algorithms can achieve the same level of expressiveness as any less conservative algorithm, by virtue of including the relevant complement classes in the input. For example, if all complement classes with respect to $\Sigma$ are included, the privative specification algorithm yields the same class system as the full specification one does (the singleton complement input discussed above is a special case of this). Moreover, contrastive underspecification, contrastive specification, and full specification all yield the same featurization (as well as the same class system) if every relevant complement class is included. In short, the algorithms can yield radically different class systems depending on their input -- but all can be made highly expressive by tailoring the input appropriately.

\subsection{Relation to feature theory}

As the examples in the preceding section illustrate, the most conservative algorithms (privative specification, contrastive underspecification) are able to yield class systems that are as expressive as the less conservative algorithms. However, the converse is not true. For example, full specification cannot yield a class system as unexpressive as the singleton input does under privative specification. We regard this kind of question as an interesting area for future work; but as working phonologists, we want to know which is the best algorithm to use? Put another way, what matters for feature systems? One principle is that a feature system is good to the extent that learned features render the grammar simpler and/or more insightful. For example, the use of `$+$' and `$-$' values yields insight if both values behave the same with respect to a harmony or assimilation process.

The received wisdom of the field recognizes the following cases: \begin{itemize}
    \item treat certain features as binary: e.g. all segments are either \phonfeat{+son} or \phonfeat{-son}
    \item treat certain features as privative: e.g. nasals are \phonfeat{+nasal} and all others are \phonfeat{0nasal}
    \item treat most features as ternary: e.g. all obstruents are \phonfeat{+voiced} or \phonfeat{-voiced}, but sonorants are simply \phonfeat{0voiced}
    \end{itemize}
Out of the algorithms we have discussed here, only the contrastive algorithms are capable of yielding a featurization which creates all three feature types. The distinction between contrastive underspecification and contrastive featurizations depends on whether complements of input classes with respect to their parents must also be in the input (which perhaps corresponds to phonological activeness) or can be defined implicitly. This is an issue that can be resolved empirically.

Here are the conditions under which the constrastive underspecification algorithm creates those three types of feature functions:
\begin{itemize}
    \item binary features are generated when a class $X$ and its complement $\Sigma \setminus X$ are both in the input
    \item privative features are generated when a class $X$ is in the input, but no complement (with respect to any ancestor, including its parent, $\Sigma$, and any intervening classes) is
    \item ternary features are generated when a class $X$ is in the input, and its complement $\overline{X}$ with respect to some ancestor other than $\Sigma$ is in the input
    \end{itemize}

\vspace{\baselineskip} For reasons of space, we do not prove that those are the correct conditions. Instead, we present an example which generates privative, binary, and ternary features. Let $\mathcal C$ include the following: \begin{itemize}
    \item \textit{inventory} -- \{a, i, u, l, r, m, n, \textipa{N}, p, t, k, b, d, g\}
    \item \textit{consonants} -- \{l, r, m, n, \textipa{N}, p, t, k, b, d, g\}
    \item \textit{sonorants} -- \{a, i, u, l, r, m, n, \textipa{N}\}
    \item \textit{obstruents} -- \{p, t, k, b, d, g\}
    \item \textit{coronal} -- \{n, l, r, t, d\}
    \item \textit{vowels} -- \{a, i, u\}
    \item \textit{nasals} -- \{m, n, \textipa{N}\}
    \item \textit{voiceless} -- \{p, t, k\}
    \item \textit{voiced} -- \{b, d, g\}
    \item \textit{labial} -- \{m, p, b\}
    \item \textit{dorsal} -- \{\textipa{N}, k, g\}
    \item \textit{liquids} -- \{l, r\}
    \item \textit{lateral} -- \{l\}
    \item \textit{rhotic} -- \{r\}
    \end{itemize}
The class system that results from running the contrastive underspecification algorithm on this input is shown in Fig.~\ref{fig:under}. The features \phonfeat{cons} and \phonfeat{son} are binary because each one partitions $\Sigma$. The features \phonfeat{LAB}, \phonfeat{COR}, \phonfeat{DOR}, \phonfeat{nas} and \phonfeat{liquid} are privative, because their complement (with respect to every ancestor) is not included in the input. The remaining features \phonfeat{vcd} and \phonfeat{lat} are ternary, because their complements (with respect to the parent, which is not $\Sigma$) are included in the input.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{placeholder.png}
  \caption{Big alphabet.}
  \label{fig:big_alphabet}
\end{figure}

We leave it as an exercise to the reader to investigate what happens to the `voicing' feature if the input includes the class of all phonetically voiced segments (i.e. $\Sigma \setminus \text{\{p, t, k\}}$).

It is our hope that the algorithms described in this paper might be used in generating explicitly testable empirical hypotheses on learning phonological features. Varying the input classes and the featurization method generates different predictions about the available phonological classes in a language. This is particularly true in the cases of the contrastive and full specification algorithms, where new classes are inferred based on the relationships between classes in the input. These featurizations provide a starting point for hypotheses that are testable in phonological experiments. For example, are speakers able to infer the existence of productive phonological classes for which the only evidence in the input is that the complement (with respect to some ancestor) behaves productively? 

\subsection{Feature learning}

%% TODO: Connor to rewrite this section.

An additional consideration associated with feature theory is that the features be learnable. There exist various proposals as to how features might be learned, e.g. from acoustic data \cite{TODO}, from articulatory data \cite{TODO}, or from distributional statistics \cite{TODO}. To date, every proposal that has been fleshed out enough to be tested has proven inadequate. It seems likely to us that progress will come from integrating multiple sources of information. In this section, we sketch an approach being undertaken in \citeA{MayerInProgress} detailing how the algorithms described in this paper might be integrated with the identification of classes using distributional and phonetic criteria to learn a feature system.

A Bayesian approach to the learning of phonological classes seems promising for several reasons. Broadly speaking, this consists of some objective function that we try to maximize by considering various configurations of input classes. 

First, a central observation in phonological theory is that similar sounds seem to behave in similar ways across languages, whether in phonotactic constraints or phonological alternations. Approaches that take feature systems to be learned and language-specific account for this by positing groupings based on phonetic similarity between sounds (be this articulatory, acoustic, or perceptual) and the propensities of such groups to undergo similar types of sound change \cite<e.g.>{Blevins2004, Mielke2008}. Such measures of phonetic similarity serve as a useful prior in a Bayesian system, stipulating that phonological classes should tend to be phonetically cohesive along one or more dimensions, and suggesting an initial classification based on the phonetic properties of the segments in a particular language. It is worth noting that a multidimensional approach is crucial here: for example, although the sonorant/obstruent distinction is widespread in languages, sonorants are articulatorily heterogenous, with little in common except voicing. Quantificational measures that distinguish between obstruents and sonorants have been proposed, however, based on acoustic and aerodynamic measurements \cite{Paker2002} and on laryngeal measurements \cite{Mielke2012}. Conversely, classes based on place of articulation are (not surprisingly) more apparent from articulatory data than from any other source \cite{Mielke2012}.

With these priors in place, candidate classes can be determined from both phonetic data, as described above, and from distributional data, where we predict that segments forming a class will tend to occur in the same types of environments and undergo the same alternations \cite<see e.g.>{GoldsmithXanthos2009, PeperkampEtAl2006}. This distributional information supports which of the possible phonetically homogenous classes are active in a language, and crucially, whether there are active phonologically disparate classes.

The learning process consists of adding classes and accepting them or rejecting them depending on whether their resulting featurization improves the objective function. The likelihood of a data set given a proposed featurization can be calculated using something like the \citeA{HayesWilson2008} constraint learner, which given a data set and a featurization of its segments, produces a set of learned constraints and a likelihood measure. An additional benefit of a Bayesian approach is that it constraints the number of proposed classes. It would be trivial to provide a class system that is an excellent fit to the data by simply featurizing the power set of the alphabet, but it is simple to configure the objective function to penalize such excess.

\section{Conclusion}

This paper provides a detailed formalization of the properties of phonological feature systems and describes algorithms for efficiently calculating various types of featurizations of a set of input classes. An implementation of these algorithms is available for use in further research. We believe that this work provides a stronger formal grounding for the study of phonological features, and that the predictions made by the algorithms for various inputs and featurization types provide useful, testable empirical hypotheses for future experimental phonological research.

\appendix

\section{Soundness proof: Intersectional closure algorithm}

The proof goes by induction. First, we show that every class which can be generated by the intersection of $0$ classes ($\Sigma$) or 1 class from $\mathcal C$ (i.e. $\mathcal C$ itself) belongs to $\mathcal C_\cap$. Next, we prove the induction step: if every class that can be generated by the intersection of $n$ classes from $\mathcal C$ is in $\mathcal C_\cap$, then every class that can be generated by the intersection of $n+1$ classes from $\mathcal C$ is in $\mathcal C_\cap$.

Observe that $\mathcal C_\cap$ is initialized to contain $\Sigma$. Moreover, $\mathcal Q$ is initialized to contain every class in $\mathcal C$. Each of these must be `transferred' to the intersectional closure because they do not belong to it already (dequeued from $\mathcal Q$, and appended to $\mathcal C_\cap$). This demonstrates that every intersection of 0 classes ($\Sigma$) and 1 class from $\mathcal C$ (namely, $\mathcal C$ itself) belongs to $\mathcal C_\cap$.

Now, suppose that the algorithm has guaranteed that every intersection of $n$ classes from $\mathcal C$ is in $\mathcal C_\cap$. If there exists a $Y \in \mathcal C_\cap$ which can be written as the intersection of $n+1$ classes, i.e. $Y = X_1 \cap X_2 \cap \ldots \cap X_{n+1} = Y' \cap X_{n+1}$ where $Y' = X_1 \cap X_2 \cap \ldots \cap X_n$. Since every intersection of $n$ classes is in $\mathcal C_\cap$, $Y'$ must be in $\mathcal C_\cap$. Now, regardless of whether $X_{n+1}$ was transferred from $\mathcal Q$ to $\mathcal C_\cap$ before or after $Y'$ was, there was some point at which one was in $\mathcal Q$ and the other in $\mathcal C_\cap$. When the \textbf{for} loop dequeued the one in $\mathcal Q$, it added the intersection of this one with all others in $\mathcal C_\cap$ -- i.e. $Y' \cap X_{n+1}$. Either this class was already in $\mathcal C_\cap$, or else it was not; and in the latter case, it was transferred. Thus, all sets generated by the intersection of $n+1$ classes from $\mathcal C$ are in $\mathcal C_\cap$. This completes the proof.


\section{The breadth-first algorithm for adding complement classes}

The contrastive and full featurization algorithms add classes to $\mathcal{C_\cap}$ during their execution. In order to avoid specifying spurious features, the order in which classes are considered is crucial: specifically, $\mathcal{C_\cap}$ must be traversed in breadth-first order, and the children of each node must be traversed from largest to smallest. This section provides an example of why this is the case, describes the algorithm, and provides a proof of its correctness. Contrastive specification will be used as an example, followed by a generalization to full specification.

% TODO: Rewrite this section once we have new examples
Consider the intersectional closure shown in Fig.~\ref{fig:closure}. Suppose we process the class \{\textipa{O}\} before either of the classes \{\textipa{oe}, y, \textipa{E}, i\} or \{u, y, i, \textipa{U}\}. This would add a new complement class \{\textipa{oe}, u, y\} since \{\textipa{O}\} has a single parent. However, as can be seen in Fig.~\ref{fig:contrastive}, this complement is actually unnecessary because once the complements of the two larger classes specified above are calculated, \{\textipa{O}\} will have two parents and can be picked out by the union of their features rather than requiring a new feature. This new feature effectively duplicates the work that existing features can already do.

Notice that this is only important for classes that have a single parent in the intersectional closure of the input, because the algorithm is only sensitive to the distinction between one and more than one parent. If a class with more than one parent has an additional parent added after it is processed, there is no change to the resulting poset or featurization aside from having a new feature/value pair associated with the segments of that class.

By processing classes that are higher in the poset (in the sense of having fewer edges between them and $\Sigma$) before processing lower ones, we can guarantee that when any class with a single parent in the input is processed, all of its parents that will be added by the contrastive algorithm will already be in the poset, and hence no unnecessary complements/features will be added. The algorithm that does this is a modified version of the standard breadth-first search (BFS) algorithm, which traverses a graph by considering all the sisters of any node before moving to its children. This algorithm differs from standard BFS algorithms because it modifies the graph as it moves through it: when a class's children are to be added to the queue, the algorithm looks at whether it is the only parent of each child. If so, it adds the complement of that child with respect to itself as one of its children. It then looks at whether its other children are subsets of this new class, and, if so, removes them from the list of children to be added.

\vspace{\baselineskip} \noindent \begin{algorithmic}
	\REQUIRE $\mathcal C_\cap$ is the intersectional closure of input class system $(\mathcal C, \Sigma)$
	\STATE
	\STATE $\mathcal Q \leftarrow \{\Sigma\}$
	\STATE $\mathcal D \leftarrow \varnothing$
	\STATE
	\WHILE{$\mathcal Q \neq \varnothing$}
	\STATE $X \leftarrow \textsc{dequeue}(\mathcal Q)$
	\STATE $C \leftarrow \textsc{SortLargeToSmall}(\textsc{children}(X))$
	\STATE $C' \leftarrow \varnothing$
	\WHILE{$C \neq \varnothing$}
	\STATE $c \leftarrow \textsc{dequeue}(C)$
	\IF{$| \textsc{parents}(c) | = 1 \land c \not \in D$}
	\STATE $\overline{c} \leftarrow X \setminus c$
	\STATE $\mathcal C_\cap \leftarrow \textsc{IntersectionalClosure}(\mathcal C_\cap, \mathcal Q' = \{\overline{c}\})$
	\FOR{$c' \in C$}
	\IF{$c' \subset \overline{c}$}
		\STATE $\textsc{remove}(C, c')$
	\ENDIF
	\STATE $\textsc{append}(C', \overline{c})$
	\STATE $\textsc{append}(D, \overline{c})$
	\ENDFOR
	\STATE $\textsc{append}(C', c)$
	\STATE $\textsc{append}(D, c)$
	\ENDIF
	\ENDWHILE
	\STATE $\textsc{enqueue}(\mathcal{Q}, C')$
	\ENDWHILE
\end{algorithmic}

The algorithm above guarantees that at the time the number of parents of $c$ is checked, all of the parents that would be added by the algorithm will already be present if $c$ only had a single parent in the input.

\vspace{\baselineskip} \noindent \textit{Proof}: 
Consider two classes $X$ and $Y$, each with a single parent, and assume without loss of generality that $Y$ is processed after $X$. Suppose that when $Y$ is processed, $\overline{Y}$, the complement of $Y$ with respect to its parent $Z$ that is added at this point, becomes a parent of $X$.

If $\overline{Y}$ is a parent of $X$, then $X$ must either be a daughter or a descendant of $Z$. If $X$ is a descendant of $Z$ but not a daughter, then by definition of the algorithm $X$ cannot have already been processed: the node currently being processed is $Y$, $Y$ is a daughter of $Z$, and all daughters of $Z$ are processed before any further descendants of $Z$. This results in a contradiction, and thus $X$ must be a daughter of $Z$.

$X \cap Y = \varnothing$, or $\overline{Y}$ would not be a parent of $X$. If $X$ has already been processed, it must be the case that $\overline{X} = Z \setminus X$ has already been added to the poset since $Z$ is the only parent of $X$. Because $X \cap Y = \varnothing$, it must be the case that $Y \subset \overline{X}$. But then $Y \subset \overline{X} \subset Z$, which means $Y$ cannot be a daughter of $Z$. This results in a contradiction and completes the proof.

TODO: Talk about processing children in sorted order and give example of where this makes a difference.

The algorithm for adding complement classes in full specification is virtually identical to the one presented above, except that we take the complement with respect to the alphabet and not the parent class (i.e., $\overline{c} \leftarrow \Sigma \setminus c$). 

TODO: The proof for the full version is actually a little tricky, and doesn't really follow nicely from the proof of the contrastive version above. There might be something linking the two I'm missing. It may also be the case that this isn't true!

What we want to prove is that if a class $X$ with a single parent has been processed already (and hence a new complement $\overline{X}$ wrt $\Sigma$ added), no later class $Y$ will add a new complement that becomes an additional parent of $X$.

Some observations, assuming $X$ has already been processed and $\overline{Y}$ ends up being a parent of $X$ as above. Assume that $X_p$ is the single parent of $X$ prior to this and $Y_p$ is the single parent of $Y$:
\begin{itemize}
	\item $X \cap Y = \varnothing$ or $\overline{Y}$ wouldn't be a parent of $X$.
	\item $\overline{X}$ will have already been added and it MUST be the case that $Y_p \subseteq \overline{X}$. If this weren't the case, both $\overline{X}$ and $Y_p$ would be parents of $Y$, and $\overline{Y}$ wouldn't be added. This doesn't preclude $\overline{X}$ from being the parent of $Y$. 
	\item It follows that $X \cap Y_p = \varnothing$, or $\overline{X}$ wouldn't be a superset of $Y_p$. 
	\item It must be the case that $X_p \cap \overline{Y} = X$, by the definition of parenthood earlier in the paper.
	\item By the same token, $X_p \not \subset \overline{Y}$ and $\overline{Y} \not \subset X_p$, or the number of parents $X$ has wouldn't change.
	\item I think it follows from this that $X_p \cap Y \neq \varnothing$, or $\overline{Y}$ would be a superset/subset of $X_p$.
\end{itemize}

I've been trying to produce a proof by contradiction using these facts, but nothing has been forthcoming. It's possible that this is just not true, but I'm also having a hard time creating a counter-example. Leaving this on the back burner for now.

\bibliography{mybib.bib}
\bibliographystyle{apacite}

\end{document}
