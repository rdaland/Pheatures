\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or eps with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}        % so we can use the 'pretty' empty set
\usepackage{tipa}
\usepackage{graphicx}           % purdy pitchers
\usepackage{algorithmic}

\title{An algorithm to assign features to a set of natural classes}
\author{}
\author{
  Mayer, Connor \\
  \texttt{connormayer@ucla.edu}
  \and
  Daland, Robert \\
  \texttt{r.daland@gmail.com}
}
%\date{}							% Activate to display a given date or no date

\begin{document}
\maketitle

\begin{abstract}
This squib describes a dynamic programming algorithm which assigns features to a set of natural classes. The input consists of a set of classes, each containing one or more segments; in other words, a subset of the powerset of a segmental alphabet $\Sigma$. If a class can be generated as the union of existing features ( = intersection of already-processed classes), those features are propagated to every segment in the class. Otherwise, a new feature/value pair is assigned. The algorithm comes in 4 flavors, which differ with respect to complementation and how negative values are assigned. We show that these variants yield \textit{privative specification}, \textit{contrastive underspecification}, \textit{contrastive specification}, and \textit{full specification}, respectively. The main text sets out necessary background, and illustrates each variant of the algorithm. The Appendix formally proves that each algorithm is sound.
\end{abstract}

\section{Introduction}
merge what Connor wrote

\section{Definitions and notation}

Let $\Sigma$ denote an alphabet of segments. We will use the term \textit{class} to mean a subset of $\Sigma$. We will also use the notation $\mathcal P(X)$ to indicate the \textit{powerset} of $X$ -- the set of all subsets of $X$ (including the empty set $\varnothing$ and $X$ itself).

\subsection{Natural classes and natural class systems}

A \textit{natural class system} $\mathcal C$ over an alphabet $\Sigma$ is any subset of $\mathcal P(\Sigma)$ which includes $\Sigma$ itself. Formally, $\mathcal C = \{ C_i \}_{i=1}^N$, where each $C_i \subset \Sigma$. To illustrate, a natural class system for a set of vowels is shown in Fig~\ref{fig:lattice}; downward arrows indicate superset-/subset-hood.

% show an example of a natural class system: a vowel harmony lattice
% TODO: it would be great to modify this figure so the 'stray' singletons on the right are on the same 'tier' as the other singletons
\begin{figure}[h]
\includegraphics[width=0.9\textwidth]{vowelHarmony_unicode.png}
\caption{Vowel harmony lattice}
\label{fig:lattice}
\end{figure}

\subsection{Feature systems and featurizations}

% definition of feature system
\vspace{\baselineskip} A \textit{feature system} is a tuple $(\mathcal F, \Sigma, \mathcal V)$ where \begin{itemize}
    \item $\Sigma$ is a segmental alphabet, 
    \item $\mathcal V$ is a set of values, and 
    \item $\mathcal F$ is a \textit{featurization}: a set of features $\{f_j\}_{j=1}^M$, where each feature is a function $f: \Sigma \rightarrow \mathcal V$ mapping segments to feature values
    \end{itemize}

\noindent To illustrate, a feature system for the vowel harmony lattice shown in Fig.~\ref{fig:lattice} is shown below:

% table with featurization of vowel harmony lattice
\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|c|c|c|}
    \hline
        $\sigma$ & front & back & low & high & round \\ \hline
        \textipa{i} & + & -- & -- & + & -- \\
        \textipa{y} & + & -- & -- & + & + \\
        \textipa{W} & -- & + & -- & + & -- \\
        \textipa{u} & -- & + & -- & + & + \\
        \textipa{E} & + & -- & -- & -- & -- \\
        \textipa{\oe} & + & -- & -- & -- & + \\
        \textipa{2} & -- & + & -- & -- & -- \\
        \textipa{O} & -- & + & -- & -- & + \\
        \textipa{a} & -- & + & + & -- & -- \\
        \hline
    \end{tabular}
    \caption{Example of a feature system.}
    \label{table:featurization}
\end{table}

\noindent In the next subsection we formalize featural descriptors, which relate classes and feature systems.

\subsection{Featural descriptors}

Let $(\mathcal F, \Sigma, \mathcal V)$ be a feature system. We restrict $\mathcal V$ to the following possibilities: \begin{itemize}
    \item \textit{privative specification}: $\mathcal V = \{ +, 0 \}$
    \item \textit{full specification}: $\mathcal V = \{ +, - \}$
    \item \textit{contrastive specification}: $\mathcal V = \{ +, -, 0 \}$
    \end{itemize}

A \textit{featural descriptor} $\mathbf{e}$ is a set of feature/value pairs where the values cannot be $0$, $\mathbf{e} \subset (\mathcal V \setminus \{0\}) \times \mathcal F$. For example, $\mathbf{e} = [+ \text{front}, - \text{low}]$ is a featural descriptor.

To relate featural descriptors and natural classes, note that every featural descriptor $\mathbf{e}$ can be expressed in the form $\mathbf{e} = \{\alpha_k F_k\}_{k=1}^K$ (where each $\alpha_k$ is a value in $\mathcal V \setminus \{ 0 \}$, and each $F_k$ is some feature function $f_j \in \mathcal F$). Informally, we say that a featural descriptor describes the class of segments which have (at least) the feature/value pairs it contains. Formally, we write $\langle \mathbf{e} \rangle$ to indicate the natural class that corresponds to the featural descriptor $\mathbf{e}$:

$$ \langle \, \{\alpha_k F_k\}_{k=1}^K \, \rangle = \{x \in \Sigma \, | \, F_k(x) = \alpha_k \text{ for every } k \} $$

\vspace{\baselineskip} \noindent We use the notation $\mathcal V^\mathcal F$ to denote the powerset of $(\mathcal V \setminus \{0\}) \times \mathcal F$, i.e. the set of all licit featural descriptors. Lastly, we define $\langle \mathcal V^\mathcal F \rangle = \{ \langle \mathbf{e} \rangle \, | \, \mathbf{e} \in \mathcal V^\mathcal F \}$, the set of all natural classes described by some featural descriptor in $\mathcal V^\mathcal F$. We say that the feature system $(\mathcal F, \Sigma, \mathcal V)$ generates the natural class system $\langle \mathcal V^\mathcal F \rangle$.

Note that while every featural descriptor in $\mathcal V^\mathcal F$ picks out a class in $\langle \mathcal V^\mathcal F \rangle$, the two are not in 1-1 correspondence. This is because the same class can often be described by multiple featural descriptors. For example, under the the feature system of Table~\ref{table:featurization}, the featural descriptor $[+\text{front}]$ picks out the same class as the featural descriptor $[+ \text{front}, - \text{low}]$ (namely, the front vowels). Moreover, the featural descriptors $[+\text{front}, -\text{front}]$ and $[+\text{high}, +\text{low}]$ both pick out the empty set.

\vspace{\baselineskip} We say that a feature system $(\mathcal F, \Sigma, \mathcal V)$ \textit{covers} a natural class system $\mathcal C$ if $\mathcal C \subset \langle \mathcal V^\mathcal F \rangle$; in other words if the feature system provides a distinct featural representation for every class in $\mathcal C$. In the remainder of this squib, we show how to construct a feature system that covers an arbitrary natural class system $\mathcal C$.

We begin with a worked-out example illustrating the difference between privative and full specification with the same segmental alphabet. Then we introduce the notion of intersectional closure, which leads naturally to a featurization algorithm for privative specification. Simple modifications yield algorithms for contrastive and full specification.

\subsection{Example}

Let $\Sigma =$ \{R, D, T\}. Informally, the reader may think of [R] as a sonorant, [D] as a voiced obstruent, and [T] as a voiceless obstruent; accordingly we use the feature names $son$ and $vcd$. In this section, we illustrate the consequences of privative versus full specification, using featurizations that are isomorphic (that is, they match on the $+$ values, and differ only as to whether the non-$+$ values are $0$ or $-$). We begin with Table ~\ref{table:privative}.

% table with featurization of sonorants, voiced obstruents, and voiceless obstruents
\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|}
    \hline
        $\sigma$ & son & vcd \\ \hline
        R & + & + \\
        D & 0 & + \\
        T & 0 & 0 \\
        \hline
    \end{tabular}
    \caption{Sonorants and obstruents with privative specification.}
    \label{table:privative}
\end{table}

\noindent The set of natural classes it describes, and the simplest featural descriptor for each, are shown below: \begin{itemize}
  \item $[\,]$ -- \{R, D, T\}
  \item $[+\text{son}]$ -- \{R\}
  \item $[+\text{vcd}]$ -- \{R,D\}
  \end{itemize}
  
\noindent Note that this featurization provides no featural descriptor that uniquely picks out the voiceless obstruent [T], no way to pick out the obstruents [T] and [D] to the exclusion of [R], and no way to pick out the voiced obstruent [D] without [R].

Next, consider the isomorphic featurization in which the $0$'s from Table ~\ref{table:privative} are replaced with $-$'s:

% table with featurization of sonorants, voiced obstruents, and voiceless obstruents
\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|}
    \hline
        $\sigma$ & son & vcd \\ \hline
        R & + & + \\
        D & -- & + \\
        T & -- & -- \\
        \hline
    \end{tabular}
    \caption{Sonorants and obstruents with full specification.}
    \label{table:full}
\end{table}

\noindent The set of natural classes this featurization describes is much larger, because the number of (extensionally distinct) licit featural descriptors is larger: \begin{itemize}
    \item $[\,] =$ \{R, D, T\}
    \item $[+\text{son}] =$ \{R\}
    \item $[-\text{son}] =$ \{D, T\}
    \item $[+\text{vcd}] =$ \{R, D\}
    \item $[-\text{vcd}] =$ \{T\}
    \item $[-\text{son},+\text{vcd}] =$ \{D\}
    \item $[+\text{son},-\text{son}] = \varnothing$
    \end{itemize}

\noindent An important generalization emerges from comparing these featurizations: the more $0$'s in the featurization, the greater the number of distinct feature functions that will be required to cover the same natural class system. In one sense, privative specification is more complex, because it will normally involve more features. However, in another sense, it is simpler, because there are only $+$ values to handle and because it will result in fewer natural classes. Therefore, we will treat privative specification first. Prior to this, we introduce the notion of intersectional closure -- the data structure that proves useful for efficiently assigning a privative feature system.

\section{Intersectional closure}

In this section we define the \textit{intersectional closure} of a natural class system $\mathcal C$. We prove that if a feature system is expressive enough to generate all the classes in $\mathcal C$, it generates the intersectional closure. Then we give a dynamic programming algorithm which efficiently computes the intersectional closure of a natural class system, as well as the intersection relation. It turns out that these structures are exactly what is needed to efficiently assign a feature system.

\vspace{\baselineskip} The \textit{intersectional closure} of $\mathcal C$, denoted $\mathcal C_\cap$, is the natural class system consisting of every class that can be generated by the intersection of finitely many classes in $\mathcal C$. Formally, $\mathcal C_\cap = \{\, \bigcap {C' \in P}  \, | \, \exists P \in \mathcal P(\mathcal C) \}$ (where $\mathcal P(\mathcal C)$ is the powerset of $\mathcal C$). We show that if a feature system $(\mathcal F, \Sigma, \mathcal V)$ is rich enough to cover $\mathcal C$, it generates $\mathcal C_\cap$.

\vspace{\baselineskip} \noindent \textbf{Lemma}: If $\mathbf{e}_i, \mathbf{e}_j \in \mathcal V^\mathcal F$, then $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle =  \langle \mathbf{e}_i \rangle \cap \langle \mathbf{e}_j \rangle$.

\textit{Proof}: The proof proceeds by showing that $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle \subset  \langle \mathbf{e}_i \rangle \cap \langle \mathbf{e}_j \rangle$ and $ \langle \mathbf{e}_i \rangle \cap \langle \mathbf{e}_j \rangle \subset \langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$.
Let $C_i = \langle \mathbf{e}_i \rangle$ and $C_i = \langle \mathbf{e}_i \rangle$.
First, suppose $x \in C_i \cap C_j$. Then $x \in C_i$. By definition, $x$ must have the features in $\mathbf{e}_i$.
Similarly, $x \in C_j$, and therefore must have the features in $\mathbf{e}_j$.
Thus, $x$ has the features in $\mathbf{e}_i \cup \mathbf{e}_j$. This shows that $C_i \cap C_j \subset \langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$.
Now, suppose $x \in \langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$. Then $x$ has all the features of $\mathbf{e}_i$, and so $x \in C_i$.
Similarly, $x$ has all the features of $\mathbf{e}_j$, so $x \in C_j$. Therefore $x \in C_i \cap C_j$. This shows that $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle \subset C_i \cap C_j$.
Since both $C_i \cap C_j$ and $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$ are subsets of each other, they are equal.

\vspace{\baselineskip} \noindent \textbf{Theorem}: Let $\mathcal C = \{C_i\}_{i=1}^n$ be a natural class system and $(\mathcal F, \Sigma, \mathcal V)$ a feature set. If $\mathcal C \subset \langle \mathcal V^\mathcal F \rangle$, then $\mathcal C_\cap \subset\langle \mathcal V^\mathcal F \rangle $.

\textit{Proof}: Let $C$ be an arbitrary class in $\mathcal C_\cap$. By definition of $\mathcal C_\cap$, there exist $\{C\}_{i=1}^n$ such that $C_i \in \mathcal C \, \forall i$ and $C = \bigcap_i \, C_i$. The hypothesis that $\mathcal C \subset \langle \mathcal V^\mathcal F \rangle $ implies that for every $C_i$ in $\mathcal C$, there exists a featural descriptor $\mathbf{e}_i$ such that $\langle \mathbf{e}_i \rangle = C_i$. Thus, $C = \bigcap_i C_i = C_1 \cap C_2 \cap \ldots \cap C_n$ can also be written $C = \bigcap_i \, \langle \mathbf{e}_i \rangle = \langle \mathbf{e}_1 \rangle \cap  \langle \mathbf{e}_2 \rangle \cap \ldots \cap  \langle \mathbf{e}_n \rangle$. It follows by induction that $C = \langle \bigcup_i  \mathbf{e}_i \rangle$:

$C = \langle \mathbf{e}_1 \rangle \cap  \langle \mathbf{e}_2 \rangle \cap \ldots \cap  \langle \mathbf{e}_n \rangle$

$ = \langle \mathbf{e}_1 \cup \mathbf{e}_2 \rangle \cap \mathbf{e}_3 \cap \ldots \cap \langle \mathbf{e}_n \rangle$

$ = \langle \mathbf{e}_1 \cup \mathbf{e}_2 \cup \mathbf{e}_3 \rangle \cap \ldots \cap \langle \mathbf{e}_n \rangle$

$\ldots$

$= \langle \mathbf{e}_1 \cup \mathbf{e}_2 \cup \ldots \cup \mathbf{e}_n \rangle$

$= \langle \bigcup_i  \mathbf{e}_i \rangle$

\noindent The preceding chain of logic demonstrates that if a class can be expressed as the intersection of natural classes in $\mathcal C$, then its features are the union of the features in each of those classes. Thus, if $(\mathcal F, \Sigma, \mathcal V)$ covers $\mathcal C$, it covers the intersectional closure. This completes the proof.


\vspace{\baselineskip} Next, we give an algorithm which computes the intersectional closure, a modified variant of Dijkstra's shortest-paths algorithm. As we will show later, the computational benefit of precomputing the intersectional closure is that it efficiently computes the intersection relation, which reduces the computational complexity of the featurization algorithm. We assume that the input is a natural class system $\mathcal C = \{C_i\}_{i=1}^N$, whose classes are sorted in decreasing order of cardinality. (This implies that $C_i \nsubseteq C_j$ whenever $j > i$, so there is no need to check the subset relation.)

\vspace{\baselineskip} \noindent \begin{algorithmic}
    \REQUIRE $\mathcal C$ sorted by decreasing size ($|C_i| \geq |C_{i+1}| $ for every $i = 1 \ldots N-1$)
    \REQUIRE subset matrix $S$ ($N \times N$): $S_{ij} = 1$ if $C_j \subset C_i$, $0$ otherwise
    \STATE
    \STATE closure $\leftarrow \mathcal C$
    \STATE pairQueue $\leftarrow \{ (i, j) \; | \; i < j \}$
    \STATE intersections $\leftarrow \varnothing$
    \STATE
    \WHILE{pairQueue $\neq \varnothing$}
        \STATE $(i, j) \leftarrow$ \textsc{pop}(pairQueue)
        \IF{$S_{ij} = 0$}
            \STATE c $\leftarrow C_i \cap C_j$
            \IF[found an existing intersection]{c $\in$ closure}
                \STATE $k \leftarrow$ index such that $\text{closure}_k = c$
                \STATE \textsc{push} $(i, j, k) \rightarrow$ intersections
            \ELSE[found a new class!]
                \STATE $N \leftarrow |\text{closure}|$
                \STATE \textsc{append} $c$ to closure
                \STATE \textsc{resize} $S \rightarrow (N+1) \times (N+1)$
                \FOR{$k=1$ to $N$}
                    \IF[update subset matrix]{c $\subset C_k$}
                        \STATE $S_{k,N+1} \rightarrow 1$
                    \ENDIF
                    \IF{$C_k \subset$ c} \STATE $S_{N+1,k} \rightarrow 1$ \ENDIF
                    \STATE \textsc{push} $(k, N+1) \rightarrow$ pairQueue
                    \STATE \textsc{push} $(N+1,k) \rightarrow$ pairQueue
                \ENDFOR
            \ENDIF
        \ENDIF
    \ENDWHILE
\end{algorithmic}

\section{Privative specification}
achieved by assigning a new feature [+f] only, to every segment in $X$

\vspace{\baselineskip} \noindent \begin{algorithmic}
	\REQUIRE Precompute $C' = C_\cap$ from $C$
	\REQUIRE $\mathcal C'$ sorted by decreasing size ($|C'_i| \geq |C'_{i+1}| $ for every $i = 1 \ldots |C'|-1$)
	\REQUIRE parent matrix $P$ ($|C'| \times |C'|$): $P_{ij} = 1$ if $C'_j \subset C'_i \land \neg \exists k [C'_j \subset C'_k \subset C'_i]$ , $0$ otherwise
	\STATE
	\STATE classQueue $\leftarrow \{c_k \in C' | \sum_{j=1}^{|C'|}P_{jk} = 1 \}$
	\STATE $i \leftarrow 1$
	\STATE
	\WHILE{classQueue $\neq \varnothing$}
	\STATE $c_k \leftarrow$ \textsc{Pop}(classQueue)
	\STATE $f_i(x) = \begin{cases}
		+ & \mbox{if } x \in c_k \\
		0 & \mbox{otherwise}
		\end{cases} $
	\STATE $\mathcal F \leftarrow \mathcal F \cup f_i$
	\STATE $i \leftarrow i + 1$
	\ENDWHILE
\end{algorithmic}


\section{Contrastive underspecification}
achieved by assigning a new feature [+f] to every segment in $X$, and if $Y \setminus X$ (the complement of $X$ with respect to $Y$) is in the input, then [-f] is assigned to every segment in $Y \setminus X$


\vspace{\baselineskip} \noindent \begin{algorithmic}
	\REQUIRE Precompute $C' = C_\cap$ from $C$
	\REQUIRE $\mathcal C'$ sorted by decreasing size ($|C'_i| \geq |C'_{i+1}| $ for every $i = 1 \ldots |C'|-1$)
	\REQUIRE parent matrix $P$ ($|C'| \times |C'|$): $P_{ij} = 1$ if $C'_j \subset C'_i \land \neg \exists k [C'_j \subset C'_k \subset C'_i]$ , $0$ otherwise
	\STATE
	\STATE classQueue $\leftarrow \{c_k \in C' | \sum_{j=1}^{|C'|}P_{jk} = 1 \}$
	\STATE $i \leftarrow 1$
	\STATE
	\WHILE{classQueue $\neq \varnothing$}
	\STATE $c_k \leftarrow$ \textsc{Pop}(classQueue)
	\STATE parent $ = \{c_i \in C | P_{ik} = 1\}$
	\STATE $c_k' \leftarrow \mbox{parent } \setminus c_k$
	\IF{$c_k' \in C$}
	\STATE $f_i(x) = \begin{cases}
	+ & \mbox{if } x \in c_k \\
	- & \mbox{if } x \in c_k' \\
	0 & \mbox{otherwise}
	\end{cases} $
	\STATE classQueue $\leftarrow \{x \in \mbox{classQueue} | x \not= c_k' \}$
	\ELSE
	\STATE $f_i(x) = \begin{cases}
	+ & \mbox{if } x \in c_k \\
	0 & \mbox{otherwise}
	\end{cases} $
	\ENDIF
	\STATE $\mathcal F \leftarrow \mathcal F \cup f_i$
	
	\STATE $i \leftarrow i + 1$
	\ENDWHILE
\end{algorithmic}

\section{Contrastive specification}
achieved by assigning a new feature [+f] to every segment in $X$, and [-f] to every segment in $Y \setminus X$ (even if $Y \setminus X$ was not in the input)

\vspace{\baselineskip} \noindent \begin{algorithmic}
	\REQUIRE Precompute $C' = C_\cap$ from $C$
	\REQUIRE $\mathcal C'$ sorted by decreasing size ($|C'_i| \geq |C'_{i+1}| $ for every $i = 1 \ldots |C'|-1$)
	\REQUIRE parent matrix $P$ ($|C'| \times |C'|$): $P_{ij} = 1$ if $C'_j \subset C'_i \land \neg \exists k [C'_j \subset C'_k \subset C'_i]$ , $0$ otherwise
	\STATE
	\STATE classQueue $\leftarrow \{c_k \in C' | \sum_{j=1}^{|C'|}P_{jk} = 1 \}$
	\STATE $i \leftarrow 1$
	\STATE
	\WHILE{classQueue $\neq \varnothing$}
	\STATE $c_k \leftarrow$ \textsc{Pop}(classQueue)
	\STATE parent $ = \{c_i \in C | P_{ik} = 1\}$
	\STATE $c_k' \leftarrow \mbox{parent } \setminus c_k$
	\STATE $f_i(x) = \begin{cases}
	+ & \mbox{if } x \in c_k \\
	- & \mbox{if } x \in c_k' \\
	0 & \mbox{otherwise}
	\end{cases} $
	\STATE $C' \leftarrow (C' \cup \{c'_k\})$
	\STATE $\textsc{Recalculate}$ $ P $ from $C'$
	\STATE classQueue $\leftarrow \{c_l \in \mbox{classQueue} | c_l \not= c_k' \ \land \sum_{j=1}^{|C'|}P_{jl} = 1 \}$
	\STATE $\mathcal F \leftarrow \mathcal F \cup f_i$
	
	\STATE $i \leftarrow i + 1$
	\ENDWHILE
\end{algorithmic}

\section{Full specification}
achieved by assigning a new feature [+f] to every segment in $X$, and [-f] to every segment in $\Sigma \setminus X$

\vspace{\baselineskip} \noindent \begin{algorithmic}
	\REQUIRE Precompute $C' = C_\cap$ from $C$
	\REQUIRE $\mathcal C'$ sorted by decreasing size ($|C'_i| \geq |C'_{i+1}| $ for every $i = 1 \ldots |C'|-1$)
	\REQUIRE parent matrix $P$ ($|C'| \times |C'|$): $P_{ij} = 1$ if $C'_j \subset C'_i \land \neg \exists k [C'_j \subset C'_k \subset C'_i]$ , $0$ otherwise
	\STATE
	\STATE classQueue $\leftarrow \{c_k \in C' | \sum_{j=1}^{|C'|}P_{jk} = 1 \}$
	\STATE $i \leftarrow 1$
	\STATE
	\WHILE{classQueue $\neq \varnothing$}
	\STATE $c_k \leftarrow$ \textsc{Pop}(classQueue)
	\STATE $c_k' \leftarrow \Sigma \setminus c_k$
	\STATE $f_i(x) = \begin{cases}
	+ & \mbox{if } x \in c_k \\
	- & \mbox{if } x \in c_k' \\
	\end{cases} $
	\STATE $C' \leftarrow (C' \cup \{c'_k\})$
	\STATE $\textsc{Recalculate}$ $ P $ from $C'$
	\STATE classQueue $\leftarrow \{c_l \in \mbox{classQueue} | c_l \not= c_k' \ \land \sum_{j=1}^{|C'|}P_{jl} = 1 \}$
	\STATE $\mathcal F \leftarrow \mathcal F \cup f_i$
	
	\STATE $i \leftarrow i + 1$
	\ENDWHILE
\end{algorithmic}

\appendix

\section{Formal proof of the algorithm}

\subsection{Privative underspecification}

\subsection{Contrastive underspecification}

\subsection{Contrastive specification}

\subsection{Full specification}

\end{document}  