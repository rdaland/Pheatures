\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or eps with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}        % so we can use the 'pretty' empty set
\usepackage{tipa}
\usepackage{graphicx}           % purdy pitchers
\usepackage{algorithmic}
\usepackage{phonrule}

\usepackage{cite}
\usepackage{apacite}

\newtheorem{definition}{Definition}

\title{An algorithm to assign features to a set of phonological classes}
\author{}
\author{
  Mayer, Connor \\
  \texttt{connormayer@ucla.edu}
  \and
  Daland, Robert \\
  \texttt{r.daland@gmail.com}
}
\date{\vspace{-5ex}}							% Activate to display a given date or no date

\begin{document}
\maketitle

\begin{abstract}
This paper describes a collection of dynamic programming algorithms which assign features to a set of phonological classes. The input consists of a set of classes, each containing one or more segments. If a class can be generated as the union of existing features (i.e. as the intersection of already-processed classes), those features are propagated to every segment in the class. A new feature/value pair must be assigned otherwise, and we show that this occurs just in case the class has a single parent in the intersectional closure of the input. The algorithm comes in four flavors, which differ with respect to complementation and how negative values are assigned. We show that these variants yield \textit{privative specification}, \textit{contrastive underspecification}, \textit{contrastive specification}, and \textit{full specification}, respectively. 
\end{abstract}

\section{Introduction}

Features are the substantive building blocks of phonological theory. They represent phonetic qualities of speech sounds, and can be used in isolation or combination to describe individual sounds or classes of sounds \cite<e.g.,>{Saussure1959, JakobsonEtAl1952}.

The goals of feature theory are to capture the following generalizations: \begin{enumerate}
  \item segments that are made alike tend to behave alike \begin{enumerate}
        \item both within and across languages \end{enumerate}
  \item sound change tends to preserve phonetic qualities even when the host segment is altered or destroyed \end{enumerate}
For example, the English voiceless stops \{p, t, \textipa{\t{tS}}, k\} are all produced with a complete, long-lag closure of the oral cavity, and exactly these segments undergo the process of foot-initial aspiration. The feature notation \phonfeat{-continuant \\ -voiced} exposes these shared phonetic properties to the phonological grammar, and the processes which might reference them. More generally, the set of obstruents within each language tend to undergo similar voicing processes (regressive voicing assimilation within obstruent clusters, word-final devoicing, intervocalic and/or postnasal voicing, etc...). An instance of feature preservation was the fall of the yers in Old Church Slavonic. The front yer (a short, unstressed, high front vowel) deleted in most prosodic positions. However, the preceding consonant became palatalized, thereby preserving the high and front articulations, even while the vowel segment was deleted. \cite{TODO}.

Classic texts \cite<e.g.,>{ChomskyHalle1968} have assumed phonological features are \textit{universal}: all the sounds in the world's languages can be described by the same finite set of features. According to this view, speakers inherently produce and perceive speech in terms of these features, because they are the substantive `atoms' of which segments and higher prosodic constituents are composed. Children represent speech in terms of these atoms, which is why phonological processes operate on the classes they define. Feature theory is manifestly successful in explaining why many common phonological processes involve segments that share relevant phonetic properties.

However, it is also clear that many phonological processes target sets of segments that cannot be singled out by a set of phonetic properties. A canonical example is the \textit{ruki} rule of Sanskrit, in which an underlying /s/ becomes retroflexed when it occurs later in a word than any of \{r, u, k, i\} \cite{TODO}. While it has been proposed that the \textit{ruki} process originated from the distinctive (though not uniform) effects of these segments on the second and third formant of neighboring segments \cite{TODO}, it is widely agreed that no conventional feature system can pick out all four of these segments to the exclusion of others \cite{TODO}. The existence of a single, idiosyncratic rule like this is not grounds for theoretical concern. However, it seems that \textit{phonetically disparate classes} like \{r, u, k, i\} are much more common than would be expected under a universal feature system. \citeA{Mielke2008} conducted a survey of phonological processes in almost 600 languages. Of the classes which underwent or conditioned a phonological process, 71\% could be expressed as a combination of simple features by the `best' feature system he considered. To express the remaining 29\%, additional theoretical mechanisms --  such as building classes through an \textsc{OR} operation -- would be needed. These seriously compromise the explanatory power that made feature theory appealing in the first place. 

The ubiquity of phonetically disparate classes has led some researchers to propose that distinctive features are \textit{learned} and \textit{language-specific} \cite<e.g.,>{Blevins2004, Mielke2008, MacWhinneyOGrady2015, ArchangeliPulleyblank2015}: learners are able to group sounds in their languages into classes regardless of whether they have any phonetic commonality. The striking regularities that exist across languages are explained as by-products of general human cognitive capabilities, such as categorization, sensitivity to frequency, and the ability to generalize, as well as the properties of the human vocal tract and auditory system.

This sets the stage for the goals of the current paper. While some previous research has focused on what classes a given feature system defines, we instead focus on how a feature system can be learned from a set of given classes. We begin by defining a formal notation for feature systems. We then describe the \textit{intersectional closure} of a set of classes, which must be generated by any featurization of that set. Using the intersectional closure as a tool for efficient calculation, we then describe a suite of algorithms for learning various types of featurizations for a set of input classes and prove their soundness. Finally, we analyze some tradeoffs between the featurization algorithms, and discuss implications for feature theory and feature learning.

This paper makes several important contributions. First, it demonstrates a method for working backwards to feature systems underpinning learned classes of sounds. Second, it provides the code for use in future research\footnote{https://github.com/rdaland/Pheatures/}. Third, it provides a detailed formalization of what a featurization of classes entails. This allows careful reasoning about the expressiveness of such featurizations. Finally, by comparing multiple types of featurization of a set of classes, it makes explicit predictions about what classes should be describable under each type. This may be useful for future research, e.g. an artificial grammar learning experiment in which speakers are taught a nasal concord pattern and tested for generalization to non-nasal concord.

\section{Definitions and notation}

Let $\Sigma$ denote an alphabet of segments. We will use the term \textit{class} to mean a subset of $\Sigma$.

\subsection{Classes and class systems}

A \textit{class system} $(\mathcal C, \Sigma)$ consists of an alphabet $\Sigma$ and a set of classes $\mathcal C$ over that alphabet. Here is an example of a class system (the labels and segments are meant to evoke a manner hierarchy): \begin{enumerate}
  \item \textit{alphabet} -- \{V, G, L, N, T\}
  \item \textit{sonorants} -- \{V, G, L, N\}
  \item \textit{noncontinuants} -- \{N, T\}
  \item \textit{continuants} -- \{V, G, L\}
  \item \textit{singletons} -- \{V\}, \{G\}, \{L\}, \{N\}, \{T\}
  \end{enumerate}

% show an example of a class system: a manner hierarchy
\begin{figure}[h]
\includegraphics[width=0.9\textwidth]{manner_poset_privative.png}
\caption{A class system, used throughout this paper}
\label{fig:manner_input}
\end{figure}

Fig.~\ref{fig:manner_input} illustrates this class system. Each node corresponds to a class, and a downward arrow from class $X$ to class $Y$ indicates that $Y \subset X$. Note, however, that not all subset/superset relations are indicated with an arrow. For example, \{V, G, L\} is a subset of the alphabet, but there is not an arrow from the alphabet directly to \{V, G, L\}. Instead, there is a path from the alphabet, through the `intervening' class \{V, G, L, N\}, to \{V, G, L\}. The existence of such a path implies that \{V, G, L\} $\subset$ \{V, G, L, N, T\} (because the subset relation is transitive). We will use the terms \textit{parent/daughter} to refer to cases in which a subset/superset relation holds and there is no intervening class. For this reason, it is graphically convenient to represent only parent/daughter relationships in plots like Fig.~\ref{fig:manner_input}.

However, the utility of the parent/daughter relation extends beyond visualization. As we show later, the parent/daughter relation turns out to be essential for the featurization algorithm. Thus, we formalize the definition here: \begin{itemize}
    \item $X$ is a \textit{parent} of $Y$ (with respect to $\mathcal C$) if and only if $Y \subset X$, and $\nexists W \in \mathcal C \, [Y \subset W \subset X]$
    \end{itemize}
\noindent We further define $\textsc{parents}(Y, \mathcal C)$ as the set of all parents of $Y$ (with respect to $\mathcal C$). 

There are a couple of additional noteworthy aspects of Fig.~\ref{fig:manner_input}. First, the empty set is technically a daughter of the singletons (since it is a subset of everything) but it does not appear in the graph. This is because the empty set is a phonologically irrelevant class: it cannot partition the alphabet into segments which undergo a process and those which do not; and to say that it is equivalent to the source or target of a process is equivalent to saying that the process does not happen at all.\footnote{Some confusion may arise with regard to SPE-style rules, where the null set symbol is used to indicate epenthesis and deletion rules. However, in this case the null set symbol does not actually represent the null set, but a null string.} Second, the class \{N\} has two dotted arrows which extend to it, rather than a single solid line like the other classes. The dotted lines signify that \{N\} is the intersection of its parents: \{V, G, L, N\} $\cap$ \{N, T\} = \{N\}. As we will prove later, this entails that \{N\} can be expressed as the union of features which express \{V, G, L, N\} and \{N, T\} individually. Therefore, it doesn't need a new feature. The central insight of this paper is to show that the opposite is true as well: a class needs a new feature just in case it can't be expressed as the union of features of its parents. This turns out to mean that a class needs a new feature if it has a single parent. However, this statement is true not for the input, but for a derived structure we call the intersectional closure. To express these insights, it is necessary to carefully formalize the notion of feature system.

\subsection{Feature systems and featurizations}

A \textit{feature system} is a tuple $(\mathcal F, \Sigma, \mathcal V)$ where \begin{itemize}
    \item $\Sigma$ is a segmental alphabet, 
    \item $\mathcal V$ is a set of values, and 
    \item $\mathcal F$ is a \textit{featurization}: a set of features $\{f_j\}_{j=1}^M$, where each feature is a function $f: \Sigma \rightarrow \mathcal V$ mapping segments to feature values
    \end{itemize}

\noindent To illustrate, a possible feature system for the vowel system of Fig.~\ref{fig:manner_input} is shown below in Table~\ref{table:featurization}. In the next subsection we formalize featural descriptors, which relate classes and feature systems.

\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|c|c|}
    \hline
        $\sigma$ & syl & cons & apprx & son \\ \hline
        V & + & -- & + & + \\
        G & -- & -- & + & + \\
        L & -- & + & + & + \\
        N & -- & + & -- & + \\
        T & -- & + & -- & -- \\
        \hline
    \end{tabular}
    \caption{Example of a feature system.}
    \label{table:featurization}
\end{table}

\subsection{Featural descriptors}

Let $(\mathcal F, \Sigma, \mathcal V)$ be a feature system. We restrict $\mathcal V$ to the following possibilities: \begin{itemize}
    \item \textit{privative specification}: $\mathcal V = \{ +, 0 \}$
    \item \textit{full specification}: $\mathcal V = \{ +, - \}$
    \item \textit{contrastive specification}: $\mathcal V = \{ +, -, 0 \}$
    \end{itemize}

We will use the notation $\mathcal V_0$ for the set $(\mathcal V \setminus \{0\})$, i.e. the set of non-zero values. This is because zero values are a formal mechanism to achieve underspecification, and the theoretical driver for underspecification is the idea that underspecified features are phonologically inactive (i.e. cannot define classes). Then, a \textit{featural descriptor} $\mathbf{e}$ is a set of feature/value pairs where the values cannot be $0$: i.e. $\mathbf{e} \subset \mathcal V_0 \times \mathcal F$. For example, $\mathbf{e} =$  \phonfeat{+front \\ -low} is a featural descriptor.

To relate featural descriptors and phonological classes, note that every featural descriptor $\mathbf{e}$ can be expressed in the form $\mathbf{e} = \{\alpha_k F_k\}_{k=1}^K$, where each $\alpha_k$ is a value in $\mathcal V_0$, and each $F_k$ is some feature function $f_j \in \mathcal F$. Informally, we say that a featural descriptor describes the class of segments which have (at least) the feature/value pairs it contains. Formally, we write $\langle \mathbf{e} \rangle$ to indicate the class that corresponds to the featural descriptor $\mathbf{e}$:

$$ \Bigg \langle \, \{\alpha_k F_k\}_{k=1}^K \, \Bigg \rangle = \{x \in \Sigma \, \mid \, F_k(x) = \alpha_k \text{ for every } k \} $$

\vspace{\baselineskip} \noindent We use the notation $\mathcal V_0^\mathcal F$ to denote the powerset of $\mathcal V_0 \times \mathcal F$: i.e. the set of all licit featural descriptors. Lastly, we define $\langle \mathcal V_0^\mathcal F \rangle = \{ \langle \mathbf{e} \rangle \, \mid \, \mathbf{e} \in \mathcal V_0^\mathcal F \}$, the set of all classes described by some featural descriptor in $\mathcal V_0^\mathcal F$. We say that the feature system $(\mathcal F, \Sigma, \mathcal V)$ generates the class system $\langle \mathcal V_0^\mathcal F \rangle$.

Note that while every featural descriptor in $\mathcal V_0^\mathcal F$ picks out a class in $\langle \mathcal V_0^\mathcal F \rangle$, the two are not generally in 1-1 correspondence. This is because the same class can often be described by multiple featural descriptors. For example, under the the feature system of Table~\ref{table:featurization}, the featural descriptor \phonfeat{--cons} picks out the same class as the featural descriptor \phonfeat{--cons \\ +son}, namely \{V, G\}. Moreover, the featural descriptors \phonfeat{+syl \\ --syl} and \phonfeat{+syl \\ --son} both pick out the empty set.

\vspace{\baselineskip} We say that a feature system $(\mathcal F, \Sigma, \mathcal V)$ \textit{covers} a class system $(\mathcal C, \Sigma)$ if $\mathcal C \subset \langle \mathcal V_0^\mathcal F \rangle$; in other words if the feature system provides a distinct featural representation for every class in $\mathcal C$. The primary goal of this paper is to describe an algorithm for constructing a feature system that covers an arbitrary class system. Prior to this, we work an example with an extremely simple segmental alphabet. More precisely, we illustrate the importance of the value set by computing the class system generated by two different featurizations which agree on the `+' values.

\subsection{Example}

Let $\Sigma =$ \{R, D, T\} and $\mathcal{C} = $ \{\{R, D\},\{R\}\}. These letters are meant to be reminiscent of manner/voicing classes: \{R\} -- \textit{sonorant}, \{D\} -- voiced obstruent, \{T\} -- voiceless obstruent. Accordingly we use the feature names $vcd$ and $son$ (although note that as far as the algorithms we discuss here are concerned, segments are atomic symbols; phonetic substance is not considered). In this section, we illustrate the consequences of privative versus full specification, using featurizations which match on the `$+$' values, and differ only as to whether the other values are `$0$' or `$-$'. We begin with Table~\ref{table:privative}.

% table with featurization of sonorants, voiced obstruents, and voiceless obstruents
\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|}
    \hline
        $\sigma$ & son & vcd \\ \hline
        R & + & + \\
        D & 0 & + \\
        T & 0 & 0 \\
        \hline
    \end{tabular}
    \caption{Sonorants and obstruents with privative specification.}
    \label{table:privative}
\end{table}

\noindent The set of classes it describes, and the simplest featural descriptor for each, are shown below: \begin{itemize}
  \item $[\,]$ -- \{R, D, T\}
  \item $[+\text{son}]$ -- \{R\}
  \item $[+\text{vcd}]$ -- \{R, D\}
  \end{itemize}
  
\noindent Note that because featural descriptors cannot have values of `0', this featurization provides no featural descriptor that uniquely picks out the voiceless obstruent \{T\}, no way to pick out the obstruents \{T\} and \{D\} to the exclusion of \{R\}, and no way to pick out the voiced obstruent \{D\} without \{R\}.

Next, consider the featurization in which the `$0$'s from Table~\ref{table:privative} are replaced with `$-$'s:

% table with featurization of sonorants, voiced obstruents, and voiceless obstruents
\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|}
    \hline
        $\sigma$ & son & vcd \\ \hline
        R & + & + \\
        D & -- & + \\
        T & -- & -- \\
        \hline
    \end{tabular}
    \caption{Sonorants and obstruents with full specification.}
    \label{table:full}
\end{table}

\noindent The set of classes this featurization describes is much larger, because the number of (extensionally distinct) featural descriptors is larger: \begin{itemize}
    \item $[\,] =$ \{R, D, T\}
    \item $[+\text{son}] =$ \{R\}
    \item $[-\text{son}] =$ \{D, T\}
    \item $[+\text{vcd}] =$ \{R, D\}
    \item $[-\text{vcd}] =$ \{T\}
    \item $[-\text{son},+\text{vcd}] =$ \{D\}
    \item $[+\text{son},-\text{vcd}] = \varnothing$
    \end{itemize}

\noindent An important generalization emerges from comparing these featurizations: the more `$0$'s in the featurization, the fewer classes a feature system will be able to describe. Covering the same class system will generally require more distinct feature functions, the greater the number of `$0$' values the featurization contains. For example, the class system $\mathcal{C} =$ \{\{D,T\}, \{R,D\}, \{T\}, \{D\}, \{R\}\}) requires four privative feature functions, but can be covered by two full specification feature functions (namely, the two shown in \ref{table:full}).

In the next section, we introduce the notion of intersectional closure. This data structure will prove essential for efficiently assigning feature systems.

\section{Intersectional closure}

In this section we define the \textit{intersectional closure} of a class system $\mathcal{C}$ as the set of classes that can be generated by intersecting $\Sigma$ with any set of classes in $\mathcal{C}$. We relate the intersectional closure to features by showing that if a feature system is expressive enough to generate all the classes in $\mathcal{C}$, it generates the intersectional closure. Then we give a dynamic programming algorithm which efficiently computes the intersectional closure. 

\subsection{Definition}

A collection of sets $\mathcal C$ is \textit{intersectionally closed} if and only if $\forall (X, Y \in \mathcal C) \, [ X \cap Y \in \mathcal C]$.

We write $\mathcal C_\cap$ to indicate the \textit{intersectional closure} of a class system $(\mathcal C, \Sigma)$. This is the smallest intersectionally closed collection which contains $\Sigma$ and every set in $\mathcal C$. In other words, the intersectional closure does not contain any classes except $\Sigma$ and those which can be generated by finite intersections of classes from $\mathcal C$.

\subsection{Feature systems generate an intersectional closure}

Now we explain why any feature system that covers $\mathcal C$ must cover $\mathcal C_\cap$. The explanation rides on the dual relationship between featural descriptors and the classes they describe: the class described by the union of two featural descriptors is the intersection of the classes described by each of the descriptors alone. This principle can be illustrated with the following example, using the vowel system in Fig.~\ref{fig:lattice}. Let $\mathbf{e}_1 =$ \phonfeat{+front} and $\mathbf{e}_2 =$ \phonfeat{+round}. Then \begin{itemize}
    \item $\langle$\phonfeat{+front}$\rangle =$ \{\textipa{\oe}, \textipa{y}, \textipa{E}, \textipa{i}\}
    \item $\langle$\phonfeat{+round}$\rangle =$ \{\textipa{\oe}, \textipa{o}, \textipa{y}, \textipa{u}\}
    \item $\langle$\phonfeat{+front}$\rangle \cap \langle$\phonfeat{+round}$\rangle =$ \{\textipa{\oe}, \textipa{y}\}
    \item $\langle$\phonfeat{+front,+round}$\rangle =$ \{\textipa{\oe}, \textipa{y}\}
    \end{itemize}

In other words, the set of vowels that are both front and round is the intersection of the set of vowels that are front and the set of vowels that are round. The Featural Intersection Lemma proves that this kind of relationship holds for any pair of featural descriptors and the classes they describe.

\vspace{\baselineskip} \noindent \textbf{Featural Intersection Lemma}

Let $(\mathcal F, \Sigma, \mathcal V)$ be a feature system. If $\mathbf{e}_i, \mathbf{e}_j \in \mathcal V_0^\mathcal F$, then $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle =  \langle \mathbf{e}_i \rangle \cap \langle \mathbf{e}_j \rangle$.

\vspace{\baselineskip} \noindent \textit{Proof}:

The proof proceeds by showing that $ \langle \mathbf{e}_i \rangle \cap \langle \mathbf{e}_j \rangle \subset \langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$ and $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle \subset  \langle \mathbf{e}_i \rangle \cap \langle \mathbf{e}_j \rangle$.
Let $C_i = \langle \mathbf{e}_i \rangle$ and $C_j = \langle \mathbf{e}_j \rangle$.
First, suppose $x \in C_i \cap C_j$. Then $x \in C_i$. By definition, $x$ must have the features in $\mathbf{e}_i$.
Similarly, $x \in C_j$, and therefore must have the features in $\mathbf{e}_j$.
Thus, $x$ has the features in $\mathbf{e}_i \cup \mathbf{e}_j$. This shows that $C_i \cap C_j \subset \langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$.
Now, suppose $x \in \langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$. Then $x$ has all the features of $\mathbf{e}_i$, and so $x \in C_i$.
Similarly, $x$ has all the features of $\mathbf{e}_j$, so $x \in C_j$. Therefore $x \in C_i \cap C_j$. This shows that $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle \subset C_i \cap C_j$.
Since both $C_i \cap C_j$ and $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$ are subsets of each other, they are equal.
This completes the proof.

\vspace{\baselineskip} \noindent The key utility of this Lemma is that it can be applied inductively, to relate the union of multiple featural descriptors with the intersection of multiple classes.

\vspace{\baselineskip} \noindent \textbf{Intersectional Closure Covering Theorem}

Let $(\mathcal C, \Sigma)$ be a class system and $(\mathcal F, \Sigma, \mathcal V)$ a feature set. If $\mathcal C \subset \langle \mathcal V_0^\mathcal F \rangle$, then $\mathcal C_\cap \subset\langle \mathcal V_0^\mathcal F \rangle $.

\vspace{\baselineskip} \noindent \textit{Proof}:

Let $Y$ be an arbitrary class in $\mathcal C_\cap$. By definition of $\mathcal C_\cap$, there exist $\{X_i \in \mathcal C\}_{i \in I}$ (for some index set $I$, hereafter omitted) such that and $Y = \bigcap_i \, X_i$. The hypothesis that $\mathcal C \subset \langle \mathcal V_0^\mathcal F \rangle $ implies that for every such $X_i$, there exists a featural descriptor $\mathbf{e}_i$ such that $\langle \mathbf{e}_i \rangle = X_i$. Thus, $Y = \bigcap_i X_i = X_1 \cap X_2 \cap \ldots \cap X_n$ can also be written $C = \bigcap_i \, \langle \mathbf{e}_i \rangle = \langle \mathbf{e}_1 \rangle \cap \langle \mathbf{e}_2 \rangle \cap \ldots \cap \langle \mathbf{e}_n \rangle$. It follows by induction using Featural Intersection Lemma that $Y = \langle \bigcup_i \mathbf{e}_i \rangle$:

$Y = \langle \mathbf{e}_1 \rangle \cap  \langle \mathbf{e}_2 \rangle \cap \ldots \cap  \langle \mathbf{e}_n \rangle$

\quad $ = \langle \mathbf{e}_1 \cup \mathbf{e}_2 \rangle \cap \mathbf{e}_3 \cap \ldots \cap \langle \mathbf{e}_n \rangle$

\quad $ = \langle \mathbf{e}_1 \cup \mathbf{e}_2 \cup \mathbf{e}_3 \rangle \cap \ldots \cap \langle \mathbf{e}_n \rangle$

\quad $\ldots$

\quad $= \langle \mathbf{e}_1 \cup \mathbf{e}_2 \cup \ldots \cup \mathbf{e}_n \rangle$

\quad $= \langle \bigcup_i  \mathbf{e}_i \rangle$

\noindent The preceding chain of logic demonstrates that if a class can be expressed as the intersection of classes in $\mathcal C$, then its features are the union of the features in each of those classes. The intersectional closure is defined as all possible intersections of classes in $\mathcal C$. Thus, if $(\mathcal F, \Sigma, \mathcal V)$ covers $\mathcal C$, it covers the intersectional closure. This completes the proof.

\subsection{An algorithm for calculating the intersectional closure}

The following algorithm yields the intersectional closure of a class system $(\mathcal C, \Sigma)$.

\noindent \begin{algorithmic}
    \ENSURE $\mathcal C_\cap$ is the intersectional closure of the input $\mathcal C$
    \STATE
    \STATE $\mathcal C_\cap \leftarrow \{ \Sigma \} $
    \STATE $\mathcal Q \leftarrow \mathcal C$
    \STATE
    \WHILE{$\mathcal Q \neq \varnothing$}
        \STATE $X \leftarrow \textsc{dequeue}(\mathcal Q)$
        \IF{\NOT $X \in \mathcal C_\cap$}
            \FOR{$Y \in \mathcal C_\cap$}
                \STATE $\textsc{enqueue}(\mathcal Q, X \cap Y)$
            \ENDFOR
            \STATE $\textsc{append}(\mathcal C_\cap, \, X)$
        \ENDIF
    \ENDWHILE
\end{algorithmic}

\vspace{\baselineskip} \noindent \textit{Proof of soundness}:

The proof goes by induction. First, we show that every class which can be generated by the intersection of $0$ classes ($\Sigma$) or 1 class from $\mathcal C$ (i.e. $\mathcal C$ itself) belongs to $\mathcal C_\cap$. Next, we prove the induction step: if every class that can be generated by the intersection of $n$ classes from $\mathcal C$ is in $\mathcal C_\cap$, then every class that can be generated by the intersection of $n+1$ classes from $\mathcal C$ is in $\mathcal C_\cap$.

Observe that $\mathcal C_\cap$ is initialized to contain $\Sigma$. Moreover, $\mathcal Q$ is initialized to contain every class in $\mathcal C$. Each of these must be `transferred' to the intersectional closure because they do not belong to it already (dequeued from $\mathcal Q$, and appended to $\mathcal C_\cap$). This demonstrates that every intersection of 0 classes ($\Sigma$) and 1 class from $\mathcal C$ (namely, $\mathcal C$ itself) belongs to $\mathcal C_\cap$.

Now, suppose that the algorithm has guaranteed that every intersection of $n$ classes from $\mathcal C$ is in $\mathcal C_\cap$. If there exists a $Y \in \mathcal C_\cap$ which can be written as the intersection of $n+1$ classes, i.e. $Y = X_1 \cap X_2 \cap \ldots \cap X_{n+1} = Y' \cap X_{n+1}$ where $Y' = X_1 \cap X_2 \cap \ldots \cap X_n$. Since every intersection of $n$ classes is in $\mathcal C_\cap$, $Y'$ must be in $\mathcal C_\cap$. Now, regardless of whether $X_{n+1}$ was transferred from $\mathcal Q$ to $\mathcal C_\cap$ before or after $Y'$ was, there was some point at which one was in $\mathcal Q$ and the other in $\mathcal C_\cap$. When the \textbf{for} loop dequeued the one in $\mathcal Q$, it added the intersection of this one with all others in $\mathcal C_\cap$ -- i.e. $Y' \cap X_{n+1}$. Either this class was already in $\mathcal C_\cap$, or else it was not; and in the latter case, it was transferred. Thus, all sets generated by the intersection of $n+1$ classes from $\mathcal C$ are in $\mathcal C_\cap$. This completes the proof.


\subsection{Parenthood in the intersectional closure}

As we will see shortly, the advantage of explicitly computing the intersectional closure is that \textit{a new feature is required for all and only the classes which have a single parent in the intersectional closure}. The core reason for this is that if a class has two parents, it must be their intersection. We prove this here.

\vspace{\baselineskip} \noindent \textbf{Single Parenthood Theorem}

Let $(\mathcal C, \Sigma)$ be a class system and $Y \in \mathcal C_\cap$. If $X_1, X_2 \in \textsc{parents}(Y)$, then $Y = X_1 \cap X_2$.

\vspace{\baselineskip} \noindent \textit{Proof}:

First, observe that $Y \subset X_1 \cap X_2$. This follows trivially from the definition of parenthood: $X_1$ is a parent of $Y$ implies $Y \subset X_1$, $X_2$ is a parent of $Y$ implies $Y \subset X_2$, and so every element in $Y$ is in both $X_1$ and $X_2$.

Now suppose that $X_1 \cap X_2 \neq Y$. The preceding logic showed that either the two are equal, or $Y$ is a proper subset of $X_1 \cap X_2$. But the latter case creates a contradiction. By definition, $(X_1 \cap X_2)$ must be in the intersectional closure, and $X_1 \cap X_2 \subset X_1$ follows from fundamental properties of sets. Then $X_1 \cap X_2$ intervenes between $Y$ and $X_1$, contradicting the hypothesis that $Y$ is a daughter of $X_1$. Thus, $Y = X_1 \cap X_2$.
	
\vspace{\baselineskip} Note that the Single Parenthood Theorem does not logically exclude the possibility that a class may have more than two parents. Rather, it guarantees that in such cases, the intersection is the same regardless of how many parents are considered. One case in which this can happen is the null set: if $x, y, z$ are three distinct elements from $\Sigma$, then $\{ x \} \cap \{ y \} = \varnothing = \{ y \} \cap \{ z \}$. A more interesting case arises in the intersectional closure of the vowel system in Fig.~\ref{fig:lattice}, shown in Fig.~\ref{fig:closure}. 

\begin{figure}[h]
\includegraphics[width=0.9\textwidth]{vowelHarmony_closure.png}
\caption{Intersectional closure of the vowel system shown earlier}
\label{fig:closure}
\end{figure}

In this case, the largest daughters of $\Sigma$ are the \phonfeat{+front} vowels, the \phonfeat{+high} vowels, and the \phonfeat{+round} vowels. The pairwise intersections of these classes give rise to the \phonfeat{+front \\ +high}, \phonfeat{+high \\ +round}, and \phonfeat{+round \\ +front} classes. The intersection of any pair of these is \{\textipa{y}\} (the high, front, round vowel), and the intersection of all 3 is also \{\textipa{y}\}. Thus, this set has 3 parents, but the segments it contains are determined simply by having more than 1 parent.

In the next section, we give an algorithm which generates a privative feature system that covers the intersectional closure $\mathcal C_\cap$, given the input of a class system $(\mathcal C, \Sigma)$.

 \section{Privative specification}

The following algorithm yields a privative specification by assigning a different feature \phonfeat{+f} to the segments in each class with a single parent.
 
\noindent \begin{algorithmic}
    \REQUIRE $\mathcal C_\cap$ is the intersectional closure of a class system $(\mathcal C, \Sigma)$
    \ENSURE $\mathcal F$ is a featurization over $\mathcal V = \{ +, 0 \}$ which covers $\mathcal C$
    \STATE
    \STATE $\mathcal Q \leftarrow \mathcal C_\cap$
    \STATE $\mathcal F \leftarrow \varnothing$
    \STATE
    \WHILE{$\mathcal Q \neq \varnothing$}
        \STATE $X \leftarrow \textsc{pop}(\mathcal Q)$
        \IF{$|\textsc{parents}(X)| = 1$}
            \STATE define $f_X : \Sigma \rightarrow \mathcal V$ by $f_X(\sigma) = \begin{cases}
                + & \mbox{if } \sigma \in X \\
                0 & \mbox{otherwise}
                \end{cases} $
            \STATE $\textsc{append}(\mathcal F, f_X)$
        \ENDIF
    \ENDWHILE
\end{algorithmic}

\vspace{\baselineskip} \noindent \textit{Proof of soundness for the privative specification algorithm}

A featurization algorithm is \textit{sound} if for every class system $(\mathcal C, \Sigma)$, it returns a feature system which covers $\mathcal C$. To see that the privative specification algorithm is sound, note that every class in $\mathcal C_\cap$ enters the queue $\mathcal Q$. For an arbitrary class $X$ in the queue, there are 3 cases. If $X$ has 0 parents, then it is $\Sigma$, and is covered by the empty featural descriptor. If $X$ has exactly 1 parent, then the segments in $X$ get the features of that parent (which uniquely pick out the parent class), plus a new feature $f$ which distinguishes the segments in $X$ from $X$'s parent. If $X$ has more than 1 parent, then Single Parenthood Theorem shows, via the Featural Intersection Lemma, that the union of features of $X$'s parents uniquely pick out all and only the segments in $X$. Thus, each class which exits the queue has a set of features assigned to its segments which pick out that class uniquely. This completes the proof.

\vspace{\baselineskip} In Fig.~\ref{fig:privative}, we illustrate the outcome of applying the privative specification algorithm to the intersectional closure of Fig.~\ref{fig:closure}. We employ several conventions to jointly optimize readability and informativity. First, classes which have a single parent are visually highlighted using a thick, red border. These represent the classes that cannot be featurized simply by the union of their parents' features. Second, the arrow which leads to each such class is annotated with the feature/value pair that is used to distinguish it. This represents the `point' at which each feature is assigned. Note that since the algorithm assigns feature/value pairs to \textit{segments}, every daughter of the class which got a new feature also gets that feature. The set of features that is shared by all members of a class, i.e. which uniquely picks out that class and not any other, is represented under the node. The complete featurization assigned to each segment is thus represented by inspecting the singleton sets in the bottom row. For readability, we use feature names that are familiar from phonological theory when the feature picks out more than segment in isolation (but note that the algorithm knows nothing of phonetic substance -- as far as it is concerned, they are just arbitrary symbols). When the feature only picks out one segment, we name the feature after the segment.

\begin{figure}[h]
\includegraphics[width=0.9\textwidth]{vowelHarmony_privative.png}
\caption{Yield of the privative specification algorithm}
\label{fig:privative}
\end{figure}

We close this section with some observations on the properties of the privative specification algorithm and the featurization it yields. 

\subsection{Properties of privative specification}

One point to observe is that the privative specification algorithm is \textit{maximally conservative}. What we mean by this is that the resulting feature system generates the smallest class system that covers $\mathcal C$. As the Intersectional Closure Covering Theorem showed, any featurization which covers $\mathcal C$ will cover $\mathcal C_\cap$. This means that any classes which are the intersection of input classes, but which were not themselves in the input, will be `accessible' to the output feature system. But the privative specification algorithm will not make it possible to refer to any other classes, besides those necessary ones. For example, if the input contains a \phonfeat{+front} class and a \phonfeat{+round} class, it must generate a \phonfeat{+front \\ +round} class, but it will not `create' a \phonfeat{-round} class.

This might be the desired behavior. But other properties might be desired instead. For instance, one might have theoretical grounds for wishing to allow `$-$' values. One might also wish to have an \textit{economical} feature system -- one which minimizes the number of features needed to cover $\mathcal C$. It is easy to show that one can sometimes achieve a more economical  feature system by `adding' classes to the system. For example, the featurization shown in Fig.~\ref{fig:privative} contains 10 features (\textit{front}, \textit{high}, \textit{round}, plus 7 features for the individual segments that cannot be accessed as combinations of front, high, and round). It is left as an exercise for the reader to verify that if the input consists of the following classes, the privative specification algorithm returns a featurization with 7 features: \begin{itemize}
    \item \textit{front} -- \{\textipa{i},\textipa{y}, \textipa{E}, \textipa{\oe}\}
    \item \textit{back} -- \{\textipa{W}, \textipa{u}, \textipa{2}, \textipa{O}\}
    \item \textit{round} -- \{\textipa{y}, \textipa{u}, \textipa{\oe}, \textipa{O}\}
    \item \textit{unround} --  \{\textipa{i}, \textipa{W}, \textipa{E}, \textipa{2}, \textipa{a}\}
    \item \textit{high} --  \{\textipa{i}, \textipa{y}, \textipa{W}, \textipa{u}\}
    \item \textit{low} -- \{\textipa{a}\}
    \item \textit{mid} --  \{\textipa{E}, \textipa{\oe}, \textipa{2}, \textipa{O}\}
    \end{itemize}
Crucially, this featurization covers the original class system shown in Fig.~\ref{fig:lattice}. In other words, it uses fewer features while generating a richer class system.

This example is presented to make two points. First, the relationship between classes in the input and the specification algorithm is not monotone. In general, adding features to a system will make more classes accessible -- but in this example, a smaller number of features covers a larger class system. Thus, the minimal number of features needed to cover $\mathcal C$ is not predictable from a `simple' property, such as the total number of classes in $\mathcal C$. To be more precise, the proof of soundness of the privative specification algorithm gives an upper bound on the features needed to cover a class system (namely, the number of classes in the intersectional closure with a single parent). We return to the issue of feature economy and expressiveness in the Discussion section. In the meantime, we turn to the second point this example makes -- adding the `right' classes to the input is what enabled a more economical feature system. In the next sections, we explore variants of the privative specification algorithm which consider complement classes and assign `$-$' values instead of (or in addition to) `$0$' values. 

\section{Contrastive underspecification}

One of the best cases for non-privative specifications arise from complement classes, such as round vs. nonround vowels, or voiced vs. voiceless obstruents. In a language with rounding harmony, like Turkish, one would need to write one harmony rule for the \phonfeat{+round} feature, and an otherwise identical rule for the \phonfeat{+nonround} feature. By allowing features to take on opposing values, one formally recognizes the sameness of rounding with respect to the harmony process.

In canonical cases like rounding harmony and voicing assimilation, the binary feature is only relevant for certain segments. For example, in the case of rounding harmony, it is normally useful to assign the \phonfeat{+round} and \phonfeat{-round} values only to vowels. In some languages, one might wish to only assign these values to just non-low vowels, or just front vowels. In all such cases, the contrasting feature values denote complementary classes -- but complements with respect to \textit{what}?

The central insight developed in this paper is that a new feature needs to be assigned just in case a class has a single parent. This suggests that the relevant domain for complementation is with respect to the parent. This is the distinction between privative specification and contrastive underspecification: a `$-$' value is assigned when the complement of the class being processed with respect to its parent is in the input.

\vspace{\baselineskip} \noindent \begin{algorithmic}
    \REQUIRE $\mathcal C_\cap$ is the intersectional closure of input class system $(\mathcal C, \Sigma)$
    \ENSURE $\mathcal F$ is a featurization over $\mathcal V = \{ +, -, 0 \}$ which covers $\mathcal C$
    \STATE
    \STATE $\mathcal Q \leftarrow \mathcal C_\cap$
    \STATE $\mathcal F \leftarrow \varnothing$
    \STATE
    \WHILE{$\mathcal Q \neq \varnothing$}
        \STATE $X \leftarrow \textsc{dequeue}(\mathcal Q)$
        \IF{$| \textsc{parents}(X) | = 1$}
            \STATE $P_X \leftarrow \textsc{dequeue}(\textsc{parents}(X))$
            \STATE
            \STATE $\overline{X} \leftarrow \begin{cases}
                P_X \setminus X & \text{if } (P_X \setminus X) \in \mathcal C \\
                \varnothing     & \text{otherwise}
                \end{cases}$
            \STATE
            \STATE define $f_X : \Sigma \rightarrow \mathcal V$ by $f_X (\sigma) = \begin{cases}
                    + & \text{if } \sigma \in X \\
                    - & \text{if } \sigma \in \overline{X} \\
                    0 & \text{otherwise}
                    \end{cases}$
            \STATE $\textsc{append}(\mathcal F, f_X)$
        \ENDIF
    \ENDWHILE
\end{algorithmic}

\vspace{\baselineskip} \noindent The soundness of this algorithm follows from the soundness of the privative specification algorithm. That is because the contrastive underspecification algorithm yields a feature system which generates the same class system as privative specification does. The only difference between the two is that if the input contains complement sets, then contrastive underspecification will use a single feature with `$+$' and `$-$' values, where privative specification will have two features with just `$+$' values.

\vspace{\baselineskip} We illustrate this algorithm on the 3-segment system \{R, T, D\} discussed before. Suppose that the input consists of the following: \begin{itemize}
    \item \textit{obstruents} -- \{D, T\}
    \item \textit{sonorants} -- \{R\}
    \item \textit{voiced obstruents} -- \{D\}
    \item \textit{voiceless obstruents} -- \{T\}
    \end{itemize}

\noindent Then contrastive underspecification will yield the following featurization (or one which is equivalent to it, but with inverse signs):

% table with featurization of sonorants, voiced obstruents, and voiceless obstruents
\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|}
    \hline
        $\sigma$ & obstr & vcd \\ \hline
        R & -- & 0 \\
        D & + & + \\
        T & + & -- \\
        \hline
    \end{tabular}
    \caption{Sonorants and obstruents with contrastive underspecification.}
    \label{table:underspecification}
\end{table}

The term \textit{contrastive underspecification} is meant to capture that features can be binary or privative: segments will be underspecified with respect to a feature if the relevant complement class is not included in the input. For example, in Table~\ref{table:underspecification} the segment $R$ is not specified for voicing -- but it would have been if the input had included the class \{R, D\}. In the next section, we consider a variant of the algorithm which adds the complement class, even if it wasn't present in the input. We call this variant \textit{contrastive specification}.
    
\section{Contrastive specification}

Contrastive specification is very similar to contrastive underspecification. The key difference is that contrastive specification adds classes to the covering. Every complement gets a `$-$' feature, including those which were not in the input. Because of this, the intersectional closure actually changes throughout the computation. It can be updated dynamically, by running the intersectional closure algorithm, except starting with the pre-existing closure, and a queue consisting of the novel complement class. An additional important difference between this featurization and the previous two is that the ordering in which classes in $\mathcal{C_\cap}$ are processed is now crucial: in order to avoid adding spurious features, $\mathcal{C_\cap}$ must be processed using breadth-first search (i.e. each class' sisters are processed before its children). This ensures that no spurious features are added.

The algorithm proceeds in two steps: first, the complement classes are calculated during a breadth-first traversal of $\mathcal{C_\cap}$ and added. This separation of tasks is not strictly necessary, but simplifies things somewhat.

The algorithm for adding complement classes ($\textsc{AddComplementsContrastive}$) and a proof of its correctness are included in Appendix A. The algorithm for featurizing the resulting classes is shown below.

\vspace{\baselineskip} \noindent \begin{algorithmic}
    \REQUIRE $\mathcal C_\cap$ is the intersectional closure of input class system $(\mathcal C, \Sigma)$
    \ENSURE $\mathcal F$ is a featurization over $\mathcal V = \{ +, -, 0 \}$ which covers $\mathcal C$
    \STATE
    \STATE $\mathcal Q \leftarrow \textsc{AddComplementsContrastive}(\mathcal{C_\cap})$
    \STATE $\mathcal F \leftarrow \varnothing$
    \STATE
    \WHILE{$\mathcal Q \neq \varnothing$}
        \STATE $X \leftarrow \textsc{dequeue}(\mathcal Q)$
        \IF{$| \textsc{parents}(X) | = 1$}
            \STATE $P_X \leftarrow \textsc{dequeue}(\textsc{parents}(X))$
            \STATE $\overline{X} \leftarrow P_X \setminus X$
            \STATE define $f_X : \Sigma \rightarrow \mathcal V$ by $f_X (\sigma) = \begin{cases}
                    + & \text{if } \sigma \in X \\
                    - & \text{if } \sigma \in \overline{X} \\
                    0 & \text{otherwise}
                    \end{cases}$
            \STATE $\textsc{append}(\mathcal F, f_X)$
            \STATE $\textsc{remove}(\mathcal{Q}, \overline{X})$
        \ENDIF
    \ENDWHILE
\end{algorithmic}

\vspace{\baselineskip} \noindent This algorithm is sound because it considers all the classes that the privative specification algorithm does, plus others. Thus, it necessarily covers $\mathcal C$.

\vspace{\baselineskip} This algorithm is illustrated with the same vowel system that we have been using throughout, i.e. where $C$ includes the front vowels, the high vowels, the round vowels, and all singletons.

\begin{figure}[h]
\includegraphics[width=0.9\textwidth]{vowelHarmony_contrastive.png}
\caption{Class system and featurization yielded by contrastive specification}
\label{fig:contrastive}
\end{figure}

\noindent Note that the feature system yielded by contrastive specification is much more expressive than the one yielded by privative specification. However, it is still not maximally expressive, since it still contains `$0$' values. When a new feature is added, non-zero values are added only to classes that are descendants of the parent of the class that generates the new feature. For example, suppose that stridents are daughters of coronals, and coronals are daughters of $\Sigma$. Then contrastive specification will create a \phonfeat{-coronal} class (all noncoronals) and a \phonfeat{-strident} class; the latter class will include all coronal nonstridents (but will not include, e.g. labials). Thus, while the \textit{coronal} feature assigns a `$+$' or `$-$' value to every segment, the \textit{strident} feature assigns a `$0$' value to noncoronals. If it is desired to eliminate all `$0$' values, one can do complementation with respect to $\Sigma$ rather than the single parent. Indeed, that is the final variant we discuss -- full specification.

\section{Full specification}

Full specification differs from contrastive specification in that complementation is calculated with respect to the whole alphabet, rather than the parent class. Therefore, it is algorithmically almost the same as contrastive specification. As with contrastive specification, the complement classes are added first, and then features are determined. This is described in Appendix A.

\vspace{\baselineskip} \noindent \begin{algorithmic}
    \REQUIRE $\mathcal C_\cap$ is the intersectional closure of input class system $(\mathcal C, \Sigma)$
    \ENSURE $\mathcal F$ is a featurization over $\mathcal V = \{ +, - \}$ which covers $\mathcal C$
    \STATE
    \STATE $\mathcal Q \leftarrow \textsc{AddComplementsFull}(\mathcal{C_\cap})$
    \STATE $\mathcal F \leftarrow \varnothing$
    \STATE
    \WHILE{$\mathcal Q \neq \varnothing$}
        \STATE $X \leftarrow \textsc{dequeue}(\mathcal Q)$
        \IF{$| \textsc{parents}(X) | = 1$}
	        \STATE $\overline{X} \leftarrow \Sigma \setminus X$
            \STATE define $f_X : \Sigma \rightarrow \mathcal V$ by $f_X (\sigma) = \begin{cases}
                    + & \text{if } \sigma \in X \\
                    - & \text{otherwise}
                    \end{cases}$
            \STATE $\textsc{append}(\mathcal F, f_X)$
            \STATE $\textsc{remove}(\mathcal{Q}, \overline{X})$
        \ENDIF
    \ENDWHILE
\end{algorithmic}

\vspace{\baselineskip} \noindent The full specification algorithm is sound for the same reason that the contrastive specification algorithm is -- it considers a superset of classes that the privative specification algorithm does, and thus it covers the input.

\vspace{\baselineskip} The key way in which full specification differs from contrastive specification is that no privative specification can occur whatsoever. For example, if a single feature \phonfeat{+nasal} is used to pick out nasal segments, then the feature system will also generate the class \phonfeat{-nasal} consisting of all non-nasal segments. According to our understanding of nasal typology, this is probably not the desired behavior for the nasal feature. Fortunately, it can be avoided by ensuring that the nasals are generated by pre-existing features rather than needing their own feature. For example, if \phonfeat{-continuant} picks out the nasals and oral stops, while \phonfeat{+sonorant} picks out vowels, glides, liquids, and nasals, then the nasal class is picked out by \phonfeat{-continuant \\ +sonorant}. Therefore, the set of all non-nasals is not generated as a complement class (although, the set of continuant non-sonorants is, as well as the set of continuant sonorants and the set of non-continuant non-sonorants).

\section{Discussion}

In this paper, we have given a number of algorithms which assign a featurization to a set of classes, such that every class in the input can be picked out by a featural description. We gave several variants of the algorithm, differing in how conservative they are with respect to the input. The most conservative algorithm assigns a privative specification, i.e. feature functions which only pick out positively specified elements. Contrastive underspecification is achieved with the same algorithm, except that a negative specification is assigned just in case the complement of a class (with respect to the parent class) is in the input. Contrastive specification is similar, except that a negative specification is assigned even if the complement (with respect to the parent) was not in the input. Full specification is similar to contrastive specification, except the complement is taken with respect to the entire segmental alphabet. In this section, we discuss some outstanding issues, such as feature economy, how the current work bears on feature theory, and applications toward a richer theory of feature learning.

\subsection{Feature economy and expressivity}

Here we present some examples which illustrate a little more about the expressiveness of class systems, and the relation between algorithm conservativeness and expressiveness.

Let $\mathcal C = \{ \{\sigma\} \, | \, \sigma \in \Sigma \}$; that is, the input consists of all and only the singleton sets. For convenience, we will refer to this as the \textit{singleton input}. Consider what happens when the privative specification algorithm is run on the singleton input. It will yield a featurization with $n$ features, where $n$ is the cardinality of $\Sigma$, and this is because each segment gets its own feature. This featurization will only generate the classes in the input (and $\Sigma$, and $\varnothing$).

The opposite extreme is obtained by the \textit{singleton complement} input -- where the input consists not of all singleton sets, but the complement of each singleton set:  $\mathcal C = \{ \Sigma \setminus \{\sigma\} \, | \, \sigma \in \Sigma \}$. It is left as an exercise for the reader to show that when the privative specification algorithm is given this input, it generates the full powerset of $\Sigma$ -- every possible subset gets a unique combination of features. Thus, privative specification is still compatible with a maximally expressive system.

The powerset of $\Sigma$ is also generated by running the full specification algorithm on the singleton input. Thus, there are cases where a more conservative algorithm yields the same class system as a less conservative algorithm. In fact, it is generally true that the more conservative algorithms can achieve the same level of expressiveness as any less conservative algorithm, by virtue of including the relevant complement classes in the input. For example, if all complement classes with respect to $\Sigma$ are included, the privative specification algorithm yields the same class system as the full specification one does (the singleton complement input discussed above is a special case of this). Moreover, contrastive underspecification, contrastive specification, and full specification all yield the same featurization (as well as the same class system) if every relevant complement class is included. In short, the algorithms can yield radically different class systems depending on their input -- but all can be made highly expressive by tailoring the input appropriately.

\subsection{Relation to feature theory}

As the examples in the preceding section illustrate, the most conservative algorithms (privative specification, contrastive underspecification) are able to yield class systems that are as expressive as the less conservative algorithms. However, the converse is not true. For example, full specification cannot yield a class system as unexpressive as the singleton input does under privative specification. We regard this kind of question as an interesting area for future work; but as working phonologists, we are also concerned with the question of what is the best algorithm to use? Put another way, what matters for feature systems? One principle is that a feature system is good to the extent that learned features render the grammar simpler and/or more insightful. For example, the use of `$+$' and `$-$' values yields insight if both values behave the same with respect to a harmony or assimilation process.

We do not at present have strong feelings regarding what a feature system \textit{should} do. But we have something else -- the received wisdom of the field. Our sense is that modern phonologists generally \begin{itemize}
    \item treat certain features as binary: e.g. all segments are either \phonfeat{+son} or \phonfeat{-son}
    \item treat certain features as privative: e.g. nasals are \phonfeat{+nasal} and all others are \phonfeat{0nasal}
    \item treat most features as ternary: e.g. all obstruents are \phonfeat{+voiced} or \phonfeat{-voiced}, but sonorants are simply \phonfeat{0voiced}
    \end{itemize}
Out of the algorithms we have discussed here, only the contrastive algorithms are capable of yielding a featurization which creates all three feature types. The distinction between contrastive underspecification and contrastive featurizations depends on whether complements of input classes with respect to their parents must also be in the input (which perhaps corresponds to phonological activeness) or can be defined implicitly. This is an issue that can be resolved empirically.

We briefly discuss the conditions necessary for assigning each type of feature under the contrastive underspecification algorithm, and then illustrate with a `simple' example, which is nonetheless more complex than what we have introduced before. 
\begin{itemize}
    \item binary features are generated when a class $X$ and its complement $\Sigma \setminus X$ are both in the input
    \item privative features are generated when a class $X$ is in the input, but no complement (with respect to any ancestor, including its parent, $\Sigma$, and any intervening classes) is
    \item ternary features are generated when a class $X$ is in the input, and its complement $\overline{X}$ with respect to some ancestor other than $\Sigma$ is in the input
    \end{itemize}

\vspace{\baselineskip} With these points in hand, we present an example which generates privative, binary, and ternary features. Let $\mathcal C$ include the following: \begin{itemize}
    \item \textit{inventory} -- \{a, i, u, l, r, m, n, \textipa{N}, p, t, k, b, d, g\}
    \item \textit{consonants} -- \{l, r, m, n, \textipa{N}, p, t, k, b, d, g\}
    \item \textit{sonorants} -- \{a, i, u, l, r, m, n, \textipa{N}\}
    \item \textit{obstruents} -- \{p, t, k, b, d, g\}
    \item \textit{coronal} -- \{n, l, r, t, d\}
    \item \textit{vowels} -- \{a, i, u\}
    \item \textit{nasals} -- \{m, n, \textipa{N}\}
    \item \textit{voiceless} -- \{p, t, k\}
    \item \textit{voiced} -- \{b, d, g\}
    \item \textit{labial} -- \{m, p, b\}
    \item \textit{dorsal} -- \{\textipa{N}, k, g\}
    \item \textit{liquids} -- \{l, r\}
    \item \textit{lateral} -- \{l\}
    \item \textit{rhotic} -- \{r\}
    \end{itemize}
The class system that results from running the contrastive underspecification algorithm on this input is shown in Fig.~\ref{fig:under}. The features \phonfeat{cons} and \phonfeat{son} are binary because each one partitions $\Sigma$. The features \phonfeat{LAB}, \phonfeat{COR}, \phonfeat{DOR}, \phonfeat{nas} and \phonfeat{liquid} are privative, because their complement (with respect to every ancestor) is not included in the input. The remaining features \phonfeat{vcd} and \phonfeat{lat} are ternary, because their complements (with respect to the parent, which is not $\Sigma$) are included in the input.

TODO: make that fig!

We leave it as an exercise to the reader to investigate what happens to the `voicing' feature if the input includes the class of all phonetically voiced segments (i.e. $\Sigma \setminus \text{\{p, t, k\}}$).

Finally, it is our hope that the algorithms described in this paper might be used in generating explicitly testable empirical hypotheses on learning phonological features. Varying the input classes and the featurization method generates different predictions about the available phonological classes in a language. This is particularly true in the cases of the contrastive and full specification algorithms, where new classes are inferred based on the relationships between classes in the input. These featurizations provide a starting point for investigations that we think could be testable in phonological experiments: e.g. are speakers able to infer the existence of productive phonological classes that are not present in the input but arise as a consequence of the featurization of the input classes? If so, under what conditions? 

\subsection{Feature learning}

An additional consideration associated with feature theory is that the features be learnable. There exist various proposals as to how features might be learned, e.g. from acoustic data \cite{TODO}, from articulatory data \cite{TODO}, or from distributional statistics \cite{TODO}. However, every proposal that has been fleshed out enough to be tested has proven inadequate. It seems likely to us that progress will come from integrating multiple sources of information. In this section, we sketch an approach being undertaken in \citeA{MayerInProgress} detailing how the algorithms described in this paper might be integrated with the identification of classes using distributional and phonetic criteria to learn a feature system.

A Bayesian approach to the learning of phonological classes seems promising for several reasons. Broadly speaking, this consists of some objective function that we try to maximize by considering various configurations of input classes. 

First, a central observation in phonological theory is that similar sounds seem to behave in similar ways across languages, whether in phonotactic constraints or phonological alternations. Approaches that take feature systems to be learned and language-specific account for this by positing groupings based on phonetic similarity between sounds (be this articulatory, acoustic, or perceptual) and the propensities of such groups to undergo similar types of sound change \cite<e.g.>{Blevins2004, Mielke2008}. Such measures of phonetic similarity serve as a useful prior in a Bayesian system, stipulating that phonological classes should tend to be phonetically cohesive along one or more dimensions, and suggesting an initial classification based on the phonetic properties of the segments in a particular language. It is worth noting that a multidimensional approach is crucial here: for example, although the sonorant/obstruent distinction is widespread in languages, sonorants are articulatorily heterogenous, with little in common except voicing. Quantificational measures that distinguish between obstruents and sonorants have been proposed, however, based on acoustic and aerodynamic measurements \cite{Paker2002} and on laryngeal measurements \cite{Mielke2012}. Conversely, classes based on place of articulation are (not surprisingly) more apparent from articulatory data than from any other source \cite{Mielke2012}.

With these priors in place, candidate classes can be determined from both phonetic data, as described above, and from distributional data, where we predict that segments forming a class will tend to occur in the same types of environments and undergo the same alternations \cite<see e.g.>{GoldsmithXanthos2009, PeperkampEtAl2006}. This distributional information supports which of the possible phonetically homogenous classes are active in a language, and crucially, whether there are active phonologically disparate classes.

The learning process consists of adding classes and accepting them or rejecting them depending on whether their resulting featurization improves the objective function. The likelihood of a data set given a proposed featurization can be calculated using something like the \citeA{HayesWilson2008} constraint learner, which given a data set and a featurization of its segments, produces a set of learned constraints and a likelihood measure. An additional benefit of a Bayesian approach is that it constraints the number of proposed classes. It would be trivial to provide a class system that is an excellent fit to the data by simply featurizing the power set of the alphabet, but it is simple to configure the objective function to penalize such excess.

% Connor must write most of this section

% my general thought is a kind of Bayesian thing which includes analysis-by-synthesis and synthesis-by-analysis

% phonetics -- this is a prior
%	meaning, the prior likelihood of a feature system is evaluated by the goodness of fit between the set of classes it generates, and isolable phonetic dimensions of the elements in question
%	for example, generating a sonorant class should be decently favored by the prior, because Matt Parker's sonority measure is supposed to achieve a decent separation of sonorants and obstruents -- but only decently, since there is like no articulatory consistency in sonorants besides being voiced

% distributional -- this would be the likelihood function
%	a feature system is good to the extent that it proposes classes which match those in the input (according to KL divergence or what have you)
%	the basic reason that Bayesianism is good here is that it automagically punishes you for being too expressive -- weight that you put on a highly expressive system is wasted, unless you actually need those extra classes

% roughly speaking, you provide an objective function
% your update is, you get the likelihood function to give you some more classes and you check whether adding them actually improves the objective
% note that I'm hand-wavey af here. for example, if we're not modeling phonological alternations, we've already cut ourselves off from the most informative thing regarding what classes are in the input
% hmm.. maybe we should have the alternations as the pre-input, or the likelihood, or something

\section{Conclusion}

This paper provides a detailed formalization of the properties of phonological feature systems and describes algorithms for efficiently calculating various types of featurizations of a set of input classes. An implementation of these algorithms is available for use in further research. We believe that this work provides a stronger formal grounding for the study of phonological features, and that the predictions made by the algorithms for various inputs and featurization types provide useful, testable empirical hypotheses for future experimental phonological research.

\appendix

\section{The breadth-first algorithm for adding complement classes}

The contrastive and full featurization algorithms add classes to $\mathcal{C_\cap}$ during their execution. In order to avoid specifying spurious features, the order in which classes are considered is crucial: specifically, $\mathcal{C_\cap}$ must be traversed in breadth-first order, and the children of each node must be traversed from largest to smallest. This section provides an example of why this is the case, describes the algorithm, and provides a proof of its correctness. Contrastive specification will be used as an example, followed by a generalization to full specification.

% TODO: Rewrite this section once we have new examples
Consider the intersectional closure shown in Fig.~\ref{fig:closure}. Suppose we process the class \{\textipa{O}\} before either of the classes \{\textipa{oe}, y, \textipa{E}, i\} or \{u, y, i, \textipa{U}\}. This would add a new complement class \{\textipa{oe}, u, y\} since \{\textipa{O}\} has a single parent. However, as can be seen in Fig.~\ref{fig:contrastive}, this complement is actually unnecessary because once the complements of the two larger classes specified above are calculated, \{\textipa{O}\} will have two parents and can be picked out by the union of their features rather than requiring a new feature. This new feature effectively duplicates the work that existing features can already do.

Notice that this is only important for classes that have a single parent in the intersectional closure of the input, because the algorithm is only sensitive to the distinction between one and more than one parent. If a class with more than one parent has an additional parent added after it is processed, there is no change to the resulting poset or featurization aside from having a new feature/value pair associated with the segments of that class.

By processing classes that are higher in the poset (in the sense of having fewer edges between them and $\Sigma$) before processing lower ones, we can guarantee that when any class with a single parent in the input is processed, all of its parents that will be added by the contrastive algorithm will already be in the poset, and hence no unnecessary complements/features will be added. The algorithm that does this is a modified version of the standard breadth-first search (BFS) algorithm, which traverses a graph by considering all the sisters of any node before moving to its children. This algorithm differs from standard BFS algorithms because it modifies the graph as it moves through it: when a class's children are to be added to the queue, the algorithm looks at whether it is the only parent of each child. If so, it adds the complement of that child with respect to itself as one of its children. It then looks at whether its other children are subsets of this new class, and, if so, removes them from the list of children to be added.

\vspace{\baselineskip} \noindent \begin{algorithmic}
	\REQUIRE $\mathcal C_\cap$ is the intersectional closure of input class system $(\mathcal C, \Sigma)$
	\STATE
	\STATE $\mathcal Q \leftarrow \{\Sigma\}$
	\STATE $\mathcal D \leftarrow \varnothing$
	\STATE
	\WHILE{$\mathcal Q \neq \varnothing$}
	\STATE $X \leftarrow \textsc{dequeue}(\mathcal Q)$
	\STATE $C \leftarrow \textsc{SortLargeToSmall}(\textsc{children}(X))$
	\STATE $C' \leftarrow \varnothing$
	\WHILE{$C \neq \varnothing$}
	\STATE $c \leftarrow \textsc{dequeue}(C)$
	\IF{$| \textsc{parents}(c) | = 1 \land c \not \in D$}
	\STATE $\overline{c} \leftarrow X \setminus c$
	\STATE $\mathcal C_\cap \leftarrow \textsc{IntersectionalClosure}(\mathcal C_\cap, \mathcal Q' = \{\overline{c}\})$
	\FOR{$c' \in C$}
	\IF{$c' \subset \overline{c}$}
		\STATE $\textsc{remove}(C, c')$
	\ENDIF
	\STATE $\textsc{append}(C', \overline{c})$
	\STATE $\textsc{append}(D, \overline{c})$
	\ENDFOR
	\STATE $\textsc{append}(C', c)$
	\STATE $\textsc{append}(D, c)$
	\ENDIF
	\ENDWHILE
	\STATE $\textsc{enqueue}(\mathcal{Q}, C')$
	\ENDWHILE
\end{algorithmic}

The algorithm above guarantees that at the time the number of parents of $c$ is checked, all of the parents that would be added by the algorithm will already be present if $c$ only had a single parent in the input.

\vspace{\baselineskip} \noindent \textit{Proof}: 
Consider two classes $X$ and $Y$, each with a single parent, and assume without loss of generality that $Y$ is processed after $X$. Suppose that when $Y$ is processed, $\overline{Y}$, the complement of $Y$ with respect to its parent $Z$ that is added at this point, becomes a parent of $X$.

If $\overline{Y}$ is a parent of $X$, then $X$ must either be a daughter or a descendant of $Z$. If $X$ is a descendant of $Z$ but not a daughter, then by definition of the algorithm $X$ cannot have already been processed: the node currently being processed is $Y$, $Y$ is a daughter of $Z$, and all daughters of $Z$ are processed before any further descendants of $Z$. This results in a contradiction, and thus $X$ must be a daughter of $Z$.

$X \cap Y = \varnothing$, or $\overline{Y}$ would not be a parent of $X$. If $X$ has already been processed, it must be the case that $\overline{X} = Z \setminus X$ has already been added to the poset since $Z$ is the only parent of $X$. Because $X \cap Y = \varnothing$, it must be the case that $Y \subset \overline{X}$. But then $Y \subset \overline{X} \subset Z$, which means $Y$ cannot be a daughter of $Z$. This results in a contradiction and completes the proof.

TODO: Talk about processing children in sorted order and give example of where this makes a difference.

The algorithm for adding complement classes in full specification is virtually identical to the one presented above, except that we take the complement with respect to the alphabet and not the parent class (i.e., $\overline{c} \leftarrow \Sigma \setminus c$). 

TODO: The proof for the full version is actually a little tricky, and doesn't really follow nicely from the proof of the contrastive version above. There might be something linking the two I'm missing. It may also be the case that this isn't true!

What we want to prove is that if a class $X$ with a single parent has been processed already (and hence a new complement $\overline{X}$ wrt $\Sigma$ added), no later class $Y$ will add a new complement that becomes an additional parent of $X$.

Some observations, assuming $X$ has already been processed and $\overline{Y}$ ends up being a parent of $X$ as above. Assume that $X_p$ is the single parent of $X$ prior to this and $Y_p$ is the single parent of $Y$:
\begin{itemize}
	\item $X \cap Y = \varnothing$ or $\overline{Y}$ wouldn't be a parent of $X$.
	\item $\overline{X}$ will have already been added and it MUST be the case that $Y_p \subseteq \overline{X}$. If this weren't the case, both $\overline{X}$ and $Y_p$ would be parents of $Y$, and $\overline{Y}$ wouldn't be added. This doesn't preclude $\overline{X}$ from being the parent of $Y$. 
	\item It follows that $X \cap Y_p = \varnothing$, or $\overline{X}$ wouldn't be a superset of $Y_p$. 
	\item It must be the case that $X_p \cap \overline{Y} = X$, by the definition of parenthood earlier in the paper.
	\item By the same token, $X_p \not \subset \overline{Y}$ and $\overline{Y} \not \subset X_p$, or the number of parents $X$ has wouldn't change.
	\item I think it follows from this that $X_p \cap Y \neq \varnothing$, or $\overline{Y}$ would be a superset/subset of $X_p$.
\end{itemize}

I've been trying to produce a proof by contradiction using these facts, but nothing has been forthcoming. It's possible that this is just not true, but I'm also having a hard time creating a counter-example. Leaving this on the back burner for now.

\bibliography{mybib.bib}
\bibliographystyle{apacite}

\end{document}
