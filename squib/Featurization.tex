\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or eps with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}        % so we can use the 'pretty' empty set
\usepackage{tipa}
\usepackage{graphicx}           % purdy pitchers
\usepackage{algorithmic}

\title{An algorithm to assign features to a set of natural classes}
\author{}
\author{
  Mayer, Connor Joseph \\
  \texttt{connor.joseph.mayer@gmail.com}
  \and
  Daland, Robert \\
  \texttt{r.daland@gmail.com}
}
%\date{}							% Activate to display a given date or no date

\begin{document}
\maketitle

\begin{abstract}
This squib describes a dynamic programming algorithm which assigns features to a set of natural classes. The input consists of a set of classes, each containing one or more segments; in other words, a subset of the powerset of a segmental alphabet $\Sigma$. If a class can be generated as the union of existing features ( = intersection of already-processed classes), those features are propagated to every segment in the class. Otherwise, a new feature/value is assigned. The algorithm comes in 4 flavors, which differ with respect to complementation and how negative values are assigned. We show that these variants yield \textit{privative specification}, \textit{contrastive underspecification}, \textit{contrastive specification}, and \textit{full specification}, respectively. The main text sets out necessary background, and illustrates each variant of the algorithm. The Appendix formally proves that each algorithm is sound.
\end{abstract}

\section{Introduction}
merge what Connor wrote

\section{Definitions and notation}

Let $\Sigma$ denote an alphabet of segments. We will use the term \textit{class} to mean a subset of $\Sigma$. 

\subsection{Definition and example of natural class system}

% definition of natural class system
A \textit{natural class system} $\mathcal C$ is a set of classes over $\Sigma$, $\mathcal C = \{C_i\}_{i=1}^N$, which includes $\Sigma$ itself, and the empty set (i.e. $\varnothing , \Sigma \in \mathcal C$).

Readers who are familiar with the notion of \textit{lattice} will note that every natural class system forms a lattice under the subset relation. To illustrate, a vowel harmony lattice is shown below (the empty set is suppressed):

% show an example of a natural class system: a vowel harmony lattice
\begin{figure}[h]
\includegraphics[width=0.9\textwidth]{vowelHarmony_unicode.png}
\caption{Vowel harmony lattice}
\label{fig:lattice}
\end{figure}

\subsection{Definition and example of a feature system}

% definition of feature system
A \textit{feature system} is a tuple $(\mathcal F, \Sigma, \mathcal V)$ where \begin{itemize}
    \item $\Sigma$ is a segmental alphabet, 
    \item $\mathcal V$ is a set of values, and 
    \item $\mathcal F = \{f_j : \Sigma \rightarrow \mathcal V\}_{j=1}^M$ is a set of feature functions mapping segments to feature values
    \end{itemize}

We say that a feature system has \textit{privative specification} if $\mathcal V = \{ +, 0 \}$, \textit{full specification} if $\mathcal V = \{ +, - \}$, and \textit{contrastive specification} if $\mathcal V = \{ +, -, 0 \}$. We do not consider other value sets here.
        
A (fully specified) feature system for the vowel harmony lattice shown in Fig.~\ref{fig:lattice} is shown below:

% table with featurization of vowel harmony lattice
\begin{table}[h]
    \centering
    \begin{tabular} {|c||c|c|c|c|c|}
    \hline
        $\sigma$ & front & back & low & high & round \\ \hline
        \textipa{i} & + & -- & -- & + & -- \\
        \textipa{y} & + & -- & -- & + & + \\
        \textipa{W} & -- & + & -- & + & -- \\
        \textipa{u} & -- & + & -- & + & + \\
        \textipa{E} & + & -- & -- & -- & -- \\
        \textipa{\oe} & + & -- & -- & -- & + \\
        \textipa{2} & -- & + & -- & -- & -- \\
        \textipa{O} & -- & + & -- & -- & + \\
        \textipa{a} & -- & + & + & -- & -- \\
        \hline
    \end{tabular}
    \caption{Example of a (fully specified) featurization.}
    \label{table:featurization}
\end{table}

\subsection{Featural descriptors}

\vspace{\baselineskip} \noindent Let $(\mathcal F, \Sigma, \mathcal V)$ be a feature system. The following definitions will prove useful: \begin{itemize}
    \item We will refer to the set of feature functions $\mathcal F = \{f_j\}_{j=1}^M$ as a \textit{featurization} (of $\Sigma$). 
    \item A \textit{featural descriptor} $\mathbf{e}$ is a subset of $\mathcal (V \setminus \{0\}) \times \mathcal F$ \begin{itemize}
        \item in other words, $\mathbf{e}$ is a set of feature/value pairs, where the value cannot be $0$
        \item an example is $[+ \text{front}, - \text{low}]$
        \end{itemize}
    \item The natural class described by a featural descriptor $\mathbf{e}$, written $\langle \mathbf{e} \rangle$, consists of every segment which has \textit{at least} the feature/value pairs in $\mathbf{e}$ \begin{itemize}
        \item featural descriptors can be written in the form $[\alpha_k f_k]_{k \in K}$ for some index set $K$
        \item $\mathbf{e} = [\alpha_k f_k]_{k \in K}$ if and only if $\langle \mathbf{e} \rangle = \{x \in \Sigma \, | \, \forall k \in K \, [ f_k(x) = \alpha_k ] \}$
        \item for the feature system in Table~\ref{table:featurization}, the natural class described by $[+ \text{front}, - \text{low}]$ is \{\textipa{i}, \textipa{y}, \textipa{E}, \textipa{\oe}\}
        \end{itemize}
    \item Let $\mathcal V^\mathcal F$ denote the set of all licit featural descriptors over $(\mathcal F, \Sigma, \mathcal V)$ \begin{itemize}
        \item Formally, $\mathcal V^\mathcal F = \mathcal P(\mathcal (V \setminus \{0\}) \times \mathcal F)$, where $\mathcal P(X)$ is the powerset of $X$
        \item Define $\langle \mathcal V^\mathcal F \rangle = \{ \langle e \rangle \, | \, e \in \mathcal V^\mathcal F \}$
        \item In other words, $\langle \mathcal V^\mathcal F \rangle$ is the set of all natural classes that can be generated by featural descriptors over $(\mathcal F, \Sigma, \mathcal V)$
        \end{itemize}
    \end {itemize}
    
Note that while every featural descriptor in $\mathcal V^\mathcal F$ picks out a class in $\langle \mathcal V^\mathcal F \rangle$, the two are not in 1-1 correspondence. This is because the same class can often be described by multiple featural descriptors. For example, under the the vowel feature system shown in Table~\ref{table:featurization}, the featural descriptor $[+\text{front}]$ picks out the same class as the featural descriptor $[+ \text{front}, - \text{low}]$ (the front vowels); and the featural descriptors $[+\text{front}, -\text{front}]$ and $[+\text{high}, +\text{low}]$ both pick out the empty set.

\subsection{Properties of feature systems}

\vspace{\baselineskip} \noindent Let $(\mathcal F, \Sigma, \mathcal V)$ be a feature system with featurization $\mathcal F = \{f_j\}_{j=1}^M$. \begin{itemize}
    \item The \textit{feature vector} of a segment $x$ is the tuple $F(x) = (f_j(x))_{j=1}^M$.
    \item Two segments $x, y$ are \textit{featurally distinct} if and only if $F(x) \neq F(y)$; in other words, if they do not match on at least feature.
    \item The feature system is \textit{well-formed} if every pair of segments in $\Sigma$ is featurally distinct.\footnote{It is always possible to make ill-formed systems become well-formed. For example, suppose that [ptk] are not given distinct place features. One way to make the system well-formed is to add place features. Another way is to replace instances of [ptk] with a meta-symbol [T] in $\Sigma$, yielding a new segmental alphabet $\Sigma ' = \Sigma \setminus \{p,t,k\} \cup \{T\}$.}
    \item A feature $f_j$ is \textit{redundant} if $\mathcal F' = \mathcal F \setminus \{ f_j \}$ is well-formed.
    \item A featurization is \textit{efficient} if it contains no redundant features.
    \end{itemize}

It is straightforward to show that if $(\mathcal F, \Sigma, \mathcal V)$ is a well-formed feature system, then it generates a natural class system.  Our goal in the remainder of this paper is to go the opposite direction: starting with a natural class system $\mathcal C$ over an alphabet $\Sigma$, can we assign an efficient, well-formed feature system $(\mathcal F, \Sigma, \mathcal V)$ that is rich enough to generate $\mathcal C$?


\section{Intersectional closure}

In this section we define the \textit{intersectional closure} of a natural class system $\mathcal C$. We prove that if a feature system is expressive enough to generate all the classes in $\mathcal C$, it generates the intersectional closure. Then we give a dynamic programming algorithm which efficiently computes the intersectional closure of a natural class system, as well as the intersection relation. It turns out that these structures are exactly what are needed to assign an efficient feature system.

The \textit{intersectional closure} of $\mathcal C$, denoted $\mathcal C_\cap$, is the natural class system consisting of every class that can be generated by the intersection of finitely many classes in $\mathcal C$. In other words, $\mathcal C_\cap$ consists of every class in $\mathcal C$, as well as any class that can be generated by the intersection of two or more classes in $\mathcal C$.

\vspace{\baselineskip} \noindent \textbf{Theorem}: Let $\mathcal C = \{C_i\}_{i=1}^n$ be a natural class system and $(\mathcal F, \Sigma, \mathcal V)$ a feature set. If $\mathcal C \subset \langle \mathcal V^\mathcal F \rangle $, then $\mathcal C_\cap \subset\langle \mathcal V^\mathcal F \rangle $. In other words, if $(\mathcal F, \Sigma, \mathcal V)$ is rich enough to generate $\mathcal C$, it generates the intersectional closure.

\textit{Proof}: Let $C_i$, $C_j$ be classes in $\mathcal C$, so that $C_i, C_j \in \langle \mathcal V^\mathcal F \rangle$.
This means that there exist featural descriptors $\mathbf{e}_i, \mathbf{e}_j \in \mathcal V^\mathcal F$ such that $\langle \mathbf{e}_i \rangle = C_i$ and $\langle \mathbf{e}_j \rangle = C_j$.
Now $\mathbf{e}_i$ and $\mathbf{e}_j$ are set of feature/value pairs.
\textit{Claim}: $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle = C_i \cap C_j$.
Proof that $C_i \cap C_j \subset \langle \mathbf{e} \rangle$: If segment $x \in C_i \cap C_j$, then $x \in C_i$.
By definition, $x$ must have the features in $\mathbf{e}_i$; similarly, since $x \in C_j$, $x$ must have the features in $\mathbf{e}_j$. Thus, $x$ has the features in $\mathbf{e}_i \cup \mathbf{e}_j$.
Proof that $\langle \mathbf{e}_i \cup \mathbf{e}_j \rangle \subset C_i \cap C_j$. Let $x \in \langle \mathbf{e}_i \cup \mathbf{e}_j \rangle$. Then $x$ has all the features of $\mathbf{e}_i$, and so $x \in C_i$. And $x$ has all the features of $\mathbf{e}_j$, so $x \in C_j$.
This illustrates that the union operation on a pair of featural descriptors corresponds to the intersection operation on the corresponding pair natural classes.
Since union and intersection operations are associative, the extension to any number of finite unions/intersections proceeds by induction (e.g. if $C_i, C_j, C_k \in \mathcal C$, $C_i \cap C_j \cap C_k = (C_i \cap C_j) \cap C_k$; $(C_i \cap C_j) \in C_\cap$ and $C_k \in C_{\cap}$, so $C_i \cap C_j \cap C_k \in \mathcal C_\cap$).

\vspace{\baselineskip} Next, we give an algorithm which computes the intersectional closure, a modified variant of Dijkstra's shortest-paths algorithm. As we will show later, the computational benefit of precomputing the intersectional closure is that it efficiently computes the intersection relation, which reduces the computational complexity of the featurization algorithm. We assume that the input is a natural class system $\mathcal C = \{C_i\}_{i=1}^N$, whose classes are sorted in decreasing order of cardinality. (This implies that $C_i \nsubseteq C_j$ whenever $j > i$, so there is no need to check the subset relation.)

\vspace{\baselineskip} \begin{algorithmic}
    \STATE \textbf{input}: $\mathcal C = \{C_i\}_{i=1}^N$, sorted by decreasing size ($|C_i| \geq |C_{i+1}| \, \forall i$)
    \STATE \textsc{closure} $\leftarrow \mathcal C$
\end{algorithmic}

\section{Privative specification}
achieved by assigning a new feature [+f] only, to every segment in $X$

\section{Contrastive underspecification}
achieved by assigning a new feature [+f] to every segment in $X$, and if $Y \setminus X$ (the complement of $X$ with respect to $Y$) is in the input, then [-f] is assigned to every segment in $Y \setminus X$

\section{Contrastive specification}
achieved by assigning a new feature [+f] to every segment in $X$, and [-f] to every segment in $Y \setminus X$ (even if $Y \setminus X$ was not in the input)

\section{Full specification}
achieved by assigning a new feature [+f] to every segment in $X$, and [-f] to every segment in $\Sigma \setminus X$

\appendix

\section{Formal proof of the algorithm}

\subsection{Privative underspecification}

\subsection{Contrastive underspecification}

\subsection{Contrastive specification}

\subsection{Full specification}

\end{document}  